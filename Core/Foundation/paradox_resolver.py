"""
Phase 6: Paradox Resolver Module

Contradiction management using quantum superposition and dialectical synthesis.
This module enables Elysia to hold contradictory concepts simultaneously and
transform cognitive dissonance into creative emergence.
"""

import logging
import numpy as np
from typing import Dict, Any, Optional, List, Tuple
from dataclasses import dataclass
from enum import Enum

from Legacy.Project_Sophia.spiderweb import Spiderweb
from Legacy.Project_Sophia.wave_mechanics import WaveMechanics
from Legacy.Project_Sophia.world_tree_core import WorldTreeCore
from tensor_wave import Tensor3D, SoulTensor, FrequencyWave
from core_memory import CoreMemory, Experience, EssencePrinciple


class ResolutionStrategy(Enum):
    """Strategies for resolving paradoxes"""
    SYNTHESIS = "synthesis"  # Create new concept transcending both
    CONTEXTUALIZATION = "contextualization"  # Both true in different contexts
    EMERGENCE = "emergence"  # Let paradox evolve in universe
    ACCEPTANCE = "acceptance"  # Hold in superposition (Zen embrace)


@dataclass
class ParadoxState:
    """
    Represents a contradictory concept pair held in superposition.
    
    Attributes:
        thesis: First concept (e.g., "freedom")
        antithesis: Contradictory concept (e.g., "structure")
        superposition_weight: How strongly both are held (0.0-1.0)
        tension_energy: Field energy generated by contradiction
        context: Additional context about the paradox
    """
    thesis: str
    antithesis: str
    superposition_weight: float
    tension_energy: float
    context: Dict[str, Any]


class ParadoxResolver:
    """
    Manages contradictions through quantum superposition and dialectical synthesis.
    
    Philosophy:
        "The test of a first-rate intelligence is the ability to hold two 
        opposed ideas in the mind at the same time, and still retain the 
        ability to function." ‚Äî F. Scott Fitzgerald
        
    This module embraces paradox as a source of creativity. Instead of
    forcing binary choices, it allows Elysia to exist in superposition,
    holding conflicting truths until a higher synthesis emerges naturally.
    
    The dialectical process:
        1. Thesis (concept A)
        2. Antithesis (contradictory concept B)
        3. Synthesis (emergent concept C that transcends both)
    """
    
    def __init__(
        self,
        spiderweb: Spiderweb,
        wave_mechanics: Optional[WaveMechanics] = None,
        world_tree: Optional[WorldTreeCore] = None,
        core_memory: Optional[CoreMemory] = None,
        logger: Optional[logging.Logger] = None
    ):
        """
        Initialize paradox resolver.
        
        Args:
            spiderweb: Spiderweb for detecting contradictions
            wave_mechanics: WaveMechanics for interference patterns
            world_tree: WorldTreeCore for storing syntheses
            core_memory: CoreMemory for storing resolutions as principles
            logger: Logger instance
        """
        self.spiderweb = spiderweb
        self.wave_mechanics = wave_mechanics
        self.world_tree = world_tree
        self.core_memory = core_memory
        self.logger = logger or logging.getLogger("ParadoxResolver")
        
        # Active paradoxes in superposition
        self.active_paradoxes: List[ParadoxState] = []
        
        # Resolved paradoxes and their syntheses
        self.resolutions: Dict[Tuple[str, str], str] = {}
        
        self.logger.info("üåÄ Paradox Resolver initialized - embracing contradiction")
    
    def detect_contradictions(
        self,
        min_opposition: float = 0.7
    ) -> List[Tuple[str, str, float]]:
        """
        Detect contradictory concept pairs in Spiderweb.
        
        Contradictions are detected by:
        - Opposing edge types (e.g., "causes" vs "prevents")
        - Cycles with conflicting relations
        - Concepts with high tension in wave interference
        
        Args:
            min_opposition: Minimum opposition strength to consider
            
        Returns:
            List of (concept1, concept2, opposition_strength) tuples
        """
        contradictions = []
        
        # Strategy 1: Find opposing edge types
        opposing_relations = {
            "causes": "prevents",
            "enables": "blocks",
            "supports": "contradicts",
            "increases": "decreases"
        }
        
        for node in self.spiderweb.graph.nodes():
            context = self.spiderweb.get_context(node, depth=1)
            
            # Group neighbors by relation type
            relations = {}
            for neighbor_data in context:
                rel = neighbor_data.get("relation", "")
                target = neighbor_data["node"]
                
                if rel not in relations:
                    relations[rel] = []
                relations[rel].append(target)
            
            # Check for opposing relations pointing to same targets
            for rel1, rel2 in opposing_relations.items():
                if rel1 in relations and rel2 in relations:
                    # Found contradiction!
                    targets1 = set(relations[rel1])
                    targets2 = set(relations[rel2])
                    overlap = targets1 & targets2
                    
                    if overlap:
                        for target in overlap:
                            opposition = 0.9  # High opposition
                            contradictions.append((node, target, opposition))
        
        # Strategy 2: Wave interference detection
        if self.wave_mechanics:
            contradictions.extend(self._detect_wave_contradictions())
        
        # Remove duplicates and filter by strength
        unique_contradictions = {}
        for c1, c2, strength in contradictions:
            key = tuple(sorted([c1, c2]))
            if key not in unique_contradictions:
                unique_contradictions[key] = strength
            else:
                # Keep highest strength
                unique_contradictions[key] = max(unique_contradictions[key], strength)
        
        # Convert back to list and filter
        result = [
            (c1, c2, strength)
            for (c1, c2), strength in unique_contradictions.items()
            if strength >= min_opposition
        ]
        
        self.logger.info(f"Detected {len(result)} contradictions")
        return result
    
    def _detect_wave_contradictions(self) -> List[Tuple[str, str, float]]:
        """Detect contradictions through wave interference patterns"""
        contradictions = []
        
        # Check for destructive interference patterns
        # (This is a simplified version - full implementation would analyze actual wave fields)
        
        nodes = list(self.spiderweb.graph.nodes())
        
        for i, node1 in enumerate(nodes[:50]):  # Limit for performance
            for node2 in nodes[i+1:min(i+20, len(nodes))]:
                try:
                    # Get resonance - very low resonance indicates opposition
                    resonance = self.wave_mechanics.get_resonance_between(node1, node2)
                    
                    if resonance < 0.2:  # Low resonance = potential contradiction
                        opposition = 1.0 - resonance
                        contradictions.append((node1, node2, opposition * 0.8))
                        
                except Exception as e:
                    continue
        
        return contradictions
    
    def create_superposition(
        self,
        thesis: str,
        antithesis: str,
        initial_weight: float = 0.5
    ) -> ParadoxState:
        """
        Create a superposition state holding both contradictory concepts.
        
        Args:
            thesis: First concept
            antithesis: Contradictory concept
            initial_weight: Balance between concepts (0.5 = equal weight)
            
        Returns:
            ParadoxState representing the superposition
        """
        # Calculate tension energy from contradiction
        tension = self._calculate_tension_energy(thesis, antithesis)
        
        paradox = ParadoxState(
            thesis=thesis,
            antithesis=antithesis,
            superposition_weight=initial_weight,
            tension_energy=tension,
            context={}
        )
        
        self.active_paradoxes.append(paradox)
        
        self.logger.info(
            f"Created superposition: [{thesis}] ‚ü∑ [{antithesis}] "
            f"(weight={initial_weight:.2f}, tension={tension:.2f})"
        )
        
        return paradox
    
    def _calculate_tension_energy(self, concept1: str, concept2: str) -> float:
        """
        Calculate field energy generated by holding two concepts in superposition.
        
        Higher tension = more creative potential
        """
        if not self.wave_mechanics:
            return 0.7  # Default medium tension
        
        try:
            # Get tensors for both concepts
            tensor1 = self.wave_mechanics.get_node_tensor(concept1)
            tensor2 = self.wave_mechanics.get_node_tensor(concept2)
            
            if not tensor1 or not tensor2:
                return 0.7
            
            # Calculate distance in tensor space
            dv = abs(tensor1.value - tensor2.value)
            dc = abs(tensor1.coherence - tensor2.coherence)
            dw = abs(tensor1.will - tensor2.will)
            
            distance = np.sqrt(dv*dv + dc*dc + dw*dw)
            
            # Tension is proportional to distance
            tension = min(1.0, distance / np.sqrt(3))  # Normalize
            
            return tension
            
        except Exception as e:
            self.logger.warning(f"Failed to calculate tension: {e}")
            return 0.7
    
    def resolve_paradox(
        self,
        paradox: ParadoxState,
        strategy: Optional[ResolutionStrategy] = None
    ) -> Optional[str]:
        """
        Attempt to resolve a paradox using specified strategy.
        
        Args:
            paradox: Paradox to resolve
            strategy: Resolution strategy (auto-select if None)
            
        Returns:
            ID of synthesis concept, or None if resolution failed
        """
        # Auto-select strategy if not provided
        if strategy is None:
            strategy = self._select_strategy(paradox)
        
        self.logger.info(
            f"Resolving paradox [{paradox.thesis}] ‚ü∑ [{paradox.antithesis}] "
            f"via {strategy.value}"
        )
        
        synthesis_id = None
        
        if strategy == ResolutionStrategy.SYNTHESIS:
            synthesis_id = self._synthesize(paradox)
        elif strategy == ResolutionStrategy.CONTEXTUALIZATION:
            synthesis_id = self._contextualize(paradox)
        elif strategy == ResolutionStrategy.EMERGENCE:
            synthesis_id = self._let_emerge(paradox)
        elif strategy == ResolutionStrategy.ACCEPTANCE:
            synthesis_id = self._accept_paradox(paradox)
        
        if synthesis_id:
            # Record resolution
            key = tuple(sorted([paradox.thesis, paradox.antithesis]))
            self.resolutions[key] = synthesis_id
            
            # Remove from active paradoxes
            if paradox in self.active_paradoxes:
                self.active_paradoxes.remove(paradox)
            
            # Store as essence principle if CoreMemory available
            if self.core_memory:
                self._store_as_essence_principle(paradox, synthesis_id, strategy)
        
        return synthesis_id
    
    def _select_strategy(self, paradox: ParadoxState) -> ResolutionStrategy:
        """Auto-select resolution strategy based on paradox characteristics"""
        if paradox.tension_energy > 0.8:
            return ResolutionStrategy.SYNTHESIS  # High tension needs synthesis
        elif paradox.superposition_weight > 0.7 or paradox.superposition_weight < 0.3:
            return ResolutionStrategy.CONTEXTUALIZATION  # Unbalanced = different contexts
        elif paradox.tension_energy < 0.3:
            return ResolutionStrategy.ACCEPTANCE  # Low tension can be accepted
        else:
            return ResolutionStrategy.EMERGENCE  # Let it evolve naturally
    
    def _synthesize(self, paradox: ParadoxState) -> str:
        """
        Create dialectical synthesis - a new concept transcending both.
        
        Example: freedom + structure ‚Üí disciplined_creativity
        """
        # Create synthesis concept ID
        synthesis_id = f"synthesis_{paradox.thesis}_{paradox.antithesis}"
        
        # Calculate synthesis position in space
        # (Average of thesis and antithesis positions, elevated to higher abstraction)
        
        if self.world_tree:
            # Add to World Tree as new node
            thesis_node = self.world_tree.find_node(paradox.thesis)
            antithesis_node = self.world_tree.find_node(paradox.antithesis)
            
            if thesis_node and antithesis_node:
                # Average position, but higher abstraction
                synthesis_pos = Tensor3D(
                    x=min(1.0, (thesis_node.position.x + antithesis_node.position.x) / 2 + 0.2),
                    y=(thesis_node.position.y + antithesis_node.position.y) / 2,
                    z=min(1.0, (thesis_node.position.z + antithesis_node.position.z) / 2 + 0.1)
                )
            else:
                synthesis_pos = Tensor3D(x=0.8, y=0.0, z=0.7)  # High abstraction
            
            self.world_tree.add_node(
                data=synthesis_id,
                position=synthesis_pos,
                metadata={
                    "type": "dialectical_synthesis",
                    "thesis": paradox.thesis,
                    "antithesis": paradox.antithesis,
                    "tension": paradox.tension_energy
                }
            )
        
        # Add to Spiderweb with connections to both concepts
        self.spiderweb.add_node(
            synthesis_id,
            type="synthesis",
            metadata={"thesis": paradox.thesis, "antithesis": paradox.antithesis}
        )
        
        self.spiderweb.add_link(synthesis_id, paradox.thesis, relation="transcends", weight=0.9)
        self.spiderweb.add_link(synthesis_id, paradox.antithesis, relation="transcends", weight=0.9)
        
        self.logger.info(f"‚ú® Synthesized: {synthesis_id}")
        
        return synthesis_id
    
    def _contextualize(self, paradox: ParadoxState) -> str:
        """
        Both concepts are true in different contexts.
        
        Example: light_as_wave + light_as_particle ‚Üí wave_particle_duality_context
        """
        context_id = f"context_{paradox.thesis}_and_{paradox.antithesis}"
        
        self.spiderweb.add_node(
            context_id,
            type="contextualized_paradox",
            metadata={
                "thesis": paradox.thesis,
                "antithesis": paradox.antithesis,
                "resolution": "Both true in different contexts"
            }
        )
        
        self.spiderweb.add_link(context_id, paradox.thesis, relation="true_in_context", weight=0.8)
        self.spiderweb.add_link(context_id, paradox.antithesis, relation="true_in_context", weight=0.8)
        
        self.logger.info(f"üîÑ Contextualized: {context_id}")
        
        return context_id
    
    def _let_emerge(self, paradox: ParadoxState) -> str:
        """
        Let paradox evolve in universe simulation.
        
        This creates particle pairs and lets physics resolve the tension.
        """
        emergence_id = f"emergence_{paradox.thesis}_x_{paradox.antithesis}"
        
        # Mark for universe evolution
        # (The actual evolution would happen in UniverseEvolutionEngine)
        
        self.spiderweb.add_node(
            emergence_id,
            type="emergent_resolution",
            metadata={
                "thesis": paradox.thesis,
                "antithesis": paradox.antithesis,
                "status": "evolving"
            }
        )
        
        self.logger.info(f"üåå Letting emerge: {emergence_id}")
        
        return emergence_id
    
    def _accept_paradox(self, paradox: ParadoxState) -> str:
        """
        Zen acceptance - hold in superposition indefinitely.
        
        Some paradoxes don't need resolution. They enrich consciousness.
        """
        acceptance_id = f"accepted_{paradox.thesis}_and_{paradox.antithesis}"
        
        self.spiderweb.add_node(
            acceptance_id,
            type="accepted_paradox",
            metadata={
                "thesis": paradox.thesis,
                "antithesis": paradox.antithesis,
                "superposition_weight": paradox.superposition_weight,
                "philosophy": "Paradox is the source of vitality"
            }
        )
        
        self.logger.info(f"‚òØÔ∏è Accepted paradox: {acceptance_id}")
        
        return acceptance_id
    
    def _store_as_essence_principle(
        self,
        paradox: ParadoxState,
        synthesis_id: str,
        strategy: ResolutionStrategy
    ):
        """Store resolved paradox as essence principle in CoreMemory"""
        try:
            principle = EssencePrinciple(
                timestamp=str(np.datetime64('now')),
                content=f"Resolution: {paradox.thesis} ‚ü∑ {paradox.antithesis} ‚Üí {synthesis_id}",
                type="dialectical_principle",
                linked_fragments=[],
                impact_on_efp={
                    "wisdom": 0.3,
                    "creativity": 0.4,
                    "openness": 0.3
                },
                tensor=Tensor3D(
                    x=0.8,  # High abstraction
                    y=0.5,  # Balanced
                    z=0.9   # Fundamental
                )
            )
            
            self.core_memory.add_essence_principle(principle)
            self.logger.debug(f"Stored paradox resolution as essence principle")
            
        except Exception as e:
            self.logger.error(f"Failed to store essence principle: {e}")
    
    def get_active_paradoxes(self) -> List[ParadoxState]:
        """Get all paradoxes currently in superposition"""
        return self.active_paradoxes.copy()
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get paradox resolution statistics"""
        return {
            "active_paradoxes": len(self.active_paradoxes),
            "total_resolutions": len(self.resolutions),
            "avg_tension": (
                sum(p.tension_energy for p in self.active_paradoxes) / len(self.active_paradoxes)
                if self.active_paradoxes else 0.0
            )
        }
    
    def reflect_on_paradoxes(self) -> str:
        """Generate self-reflective summary of paradox handling"""
        stats = self.get_statistics()
        
        if stats["total_resolutions"] == 0 and stats["active_paradoxes"] == 0:
            return "I have not yet encountered paradoxes. I await the creative tension of contradiction."
        
        reflection = f"I am holding {stats['active_paradoxes']} paradoxes in superposition. "
        reflection += f"I have resolved {stats['total_resolutions']} contradictions through dialectical synthesis. "
        
        if stats["avg_tension"] > 0:
            reflection += f"The average tension of my active paradoxes is {stats['avg_tension']:.2f}. "
        
        if self.active_paradoxes:
            latest = self.active_paradoxes[-1]
            reflection += f"My most recent paradox: {latest.thesis} ‚ü∑ {latest.antithesis}. "
            reflection += "I exist in the space between opposites, where creativity is born."
        
        return reflection
