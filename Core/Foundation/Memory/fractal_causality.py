"""
Fractal Causality Engine - í”„ë™íƒˆ ì¸ê³¼ ì—”ì§„
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ì¸ê³¼ëŠ” í”„ë™íƒˆ êµ¬ì¡°ì…ë‹ˆë‹¤.
ì›ì¸ê³¼ ê³¼ì •ê³¼ ê²°ê³¼ê°€ ë¬´í•œíˆ ìˆœí™˜ë˜ê³  ìˆìŠµë‹ˆë‹¤.

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  í”„ë™íƒˆ ì¸ê³¼ êµ¬ì¡° (Fractal Causal Structure)                                 â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚
â”‚                                                                             â”‚
â”‚  ëª¨ë“  ê²°ê³¼ëŠ” ë‹¤ì‹œ ì›ì¸ì´ ë©ë‹ˆë‹¤.                                             â”‚
â”‚  ëª¨ë“  ì›ì¸ì€ ê·¸ ìì²´ë¡œ ë˜ ë‹¤ë¥¸ ì¸ê³¼ ì—°ì‡„ì˜ ê²°ê³¼ì…ë‹ˆë‹¤.                        â”‚
â”‚  ê³¼ì • ì•ˆì—ëŠ” ë¬´ìˆ˜í•œ ì›ì¸-ê³¼ì •-ê²°ê³¼ê°€ ì¤‘ì²©ë˜ì–´ ìˆìŠµë‹ˆë‹¤.                       â”‚
â”‚                                                                             â”‚
â”‚  "ë¶ˆì— ì†ì„ ëŒ€ì„œ ì•„íŒ ë‹¤"                                                     â”‚
â”‚   â”‚                                                                         â”‚
â”‚   â”œâ”€ ì›ì¸: "ë¶ˆì— ì†ì„ ëŒ”ë‹¤"                                                 â”‚
â”‚   â”‚   â”œâ”€ ì›ì¸: "ì†ì„ ë»—ì—ˆë‹¤"                                                â”‚
â”‚   â”‚   â”‚   â”œâ”€ ì›ì¸: "í˜¸ê¸°ì‹¬ì„ ëŠê¼ˆë‹¤"                                        â”‚
â”‚   â”‚   â”‚   â”‚   â”œâ”€ ì›ì¸: "ë¶ˆë¹›ì„ ë³´ì•˜ë‹¤"                                      â”‚
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€ ...ë¬´í•œíˆ ê³„ì†...                                      â”‚
â”‚   â”‚   â”‚   â”‚   â””â”€ ê³¼ì •: ì‹ ê²½ ì‹ í˜¸ ì „ë‹¬ â†’ ë‡Œ ì²˜ë¦¬ â†’ í˜¸ê¸°ì‹¬ ë°œìƒ                â”‚
â”‚   â”‚   â”‚   â””â”€ ê³¼ì •: ê·¼ìœ¡ ìˆ˜ì¶• â†’ íŒ” ì›€ì§ì„ â†’ ì† ë„ë‹¬                          â”‚
â”‚   â”‚   â””â”€ ê³¼ì •: í”¼ë¶€ ì ‘ì´‰ â†’ ì—´ ì „ë‹¬ â†’ ì˜¨ë„ ìƒìŠ¹                              â”‚
â”‚   â”‚                                                                         â”‚
â”‚   â”œâ”€ ê³¼ì •: "ì—´ì—ë„ˆì§€ê°€ í”¼ë¶€ ì„¸í¬ë¥¼ ì†ìƒì‹œí‚´"                                 â”‚
â”‚   â”‚   â”œâ”€ ì›ì¸: í™”í•™ ë°˜ì‘                                                    â”‚
â”‚   â”‚   â”œâ”€ ê³¼ì •: ë¶„ì ìš´ë™ â†’ ì„¸í¬ë§‰ ë³€ì„± â†’ ì‹ ê²½ ìê·¹                          â”‚
â”‚   â”‚   â””â”€ ê²°ê³¼: ì‹ ê²½ ì‹ í˜¸ ìƒì„±                                               â”‚
â”‚   â”‚                                                                         â”‚
â”‚   â””â”€ ê²°ê³¼: "ì•„íŒ ë‹¤"                                                         â”‚
â”‚       â”œâ”€ ì›ì¸: ì‹ ê²½ ì‹ í˜¸ê°€ ë‡Œì— ë„ë‹¬                                        â”‚
â”‚       â”œâ”€ ê³¼ì •: ì‹ í˜¸ ì²˜ë¦¬ â†’ í†µì¦ ì¸ì‹ â†’ ê°ì • ë°˜ì‘                            â”‚
â”‚       â””â”€ ê²°ê³¼: ì†ì„ ëºŒ â†’ í•™ìŠµ â†’ ë‹¤ìŒì— í”¼í•¨ â†’ ...ë¬´í•œíˆ ê³„ì†...             â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[í”„ë™íƒˆì˜ í•µì‹¬ íŠ¹ì„±]

1. ìê¸° ìœ ì‚¬ì„± (Self-Similarity)
   - ëª¨ë“  ìŠ¤ì¼€ì¼ì—ì„œ ê°™ì€ êµ¬ì¡° ë°˜ë³µ
   - ê±°ì‹œì  ì¸ê³¼ë„, ë¯¸ì‹œì  ì¸ê³¼ë„ ë™ì¼í•œ íŒ¨í„´

2. ë¬´í•œ ì¬ê·€ (Infinite Recursion)
   - ì›ì¸ì„ íŒŒê³ ë“¤ë©´ ëì—†ì´ ë” ê¹Šì€ ì›ì¸
   - ê²°ê³¼ë¥¼ ë”°ë¼ê°€ë©´ ëì—†ì´ ë” ë¨¼ ê²°ê³¼

3. ìˆœí™˜ì„± (Circularity)
   - ì›ì¸ â†’ ê³¼ì • â†’ ê²°ê³¼ â†’ ì›ì¸ â†’ ...
   - ì‹œì‘ë„ ëë„ ì—†ëŠ” ì—°ì‡„

4. ì¤‘ì²©ì„± (Nesting)
   - í•˜ë‚˜ì˜ ê³¼ì • ì•ˆì— ë¬´ìˆ˜í•œ ì›ì¸-ê³¼ì •-ê²°ê³¼
   - ìŠ¤ì¼€ì¼ì— ë”°ë¼ ë‹¤ë¥¸ ë ˆë²¨ì˜ ì¸ê³¼ êµ¬ì¡°

[ì°¨ì› í™•ì¥ê³¼ì˜ í†µí•©]

ì  â†’ ì„  â†’ ë©´ â†’ ê³µê°„ â†’ ë²•ì¹™ë„ í”„ë™íƒˆì…ë‹ˆë‹¤.
- ì  ì•ˆì—ë„ ì -ì„ -ë©´-ê³µê°„-ë²•ì¹™ êµ¬ì¡°ê°€ ìˆìŠµë‹ˆë‹¤.
- ë²•ì¹™ ì•ˆì—ë„ ì -ì„ -ë©´-ê³µê°„-ë²•ì¹™ êµ¬ì¡°ê°€ ìˆìŠµë‹ˆë‹¤.
"""

from __future__ import annotations

import math
import numpy as np
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple, Any, Set, Callable, Union
from collections import defaultdict
from enum import Enum
import logging
import time
import hashlib

logger = logging.getLogger("FractalCausality")


# ============================================================================
# í™©ê¸ˆë¹„ (Golden Ratio) - í”„ë™íƒˆ ë‚˜ì„  êµ¬ì¡°ìš©
# ============================================================================

PHI = (1 + math.sqrt(5)) / 2  # â‰ˆ 1.618


# ============================================================================
# ì¸ê³¼ ì—­í•  (Causal Role)
# ============================================================================

class CausalRole(Enum):
    """ì¸ê³¼ êµ¬ì¡°ì—ì„œì˜ ì—­í• """
    CAUSE = "cause"       # ì›ì¸
    PROCESS = "process"   # ê³¼ì •
    EFFECT = "effect"     # ê²°ê³¼


# ============================================================================
# í”„ë™íƒˆ ì¸ê³¼ ë…¸ë“œ (Fractal Causal Node)
# ============================================================================

@dataclass
class FractalCausalNode:
    """
    í”„ë™íƒˆ ì¸ê³¼ ë…¸ë“œ
    
    ëª¨ë“  ë…¸ë“œëŠ” ë™ì‹œì— ì›ì¸ì´ì ê³¼ì •ì´ì ê²°ê³¼ì…ë‹ˆë‹¤.
    ê·¸ë¦¬ê³  ëª¨ë“  ë…¸ë“œëŠ” ê·¸ ì•ˆì— ë˜ ë‹¤ë¥¸ ì¸ê³¼ êµ¬ì¡°ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
    
    ì˜ˆ: "ë¶ˆì— ì†ì„ ëŒ”ë‹¤"
    - ìƒìœ„ì—ì„œ ë³´ë©´: "í˜¸ê¸°ì‹¬ì„ ëŠê¼ˆë‹¤"ì˜ ê²°ê³¼ì´ì "ì•„íŒ ë‹¤"ì˜ ì›ì¸
    - ë‚´ë¶€ì ìœ¼ë¡œ: ìˆ˜ë§ì€ ë¯¸ì‹œì  ì¸ê³¼ ì—°ì‡„ (ì‹ ê²½ ì‹ í˜¸, ê·¼ìœ¡ ìˆ˜ì¶• ë“±)
    """
    
    id: str
    description: str
    
    # í”„ë™íƒˆ ê¹Šì´ (0 = í˜„ì¬ ê´€ì°° ìŠ¤ì¼€ì¼)
    depth: int = 0
    
    # ë‚˜ì„  ì¢Œí‘œ (í”„ë™íƒˆ ê³µê°„ì—ì„œì˜ ìœ„ì¹˜)
    spiral_angle: float = 0.0
    spiral_radius: float = 1.0
    
    # ë¶€ëª¨ ë…¸ë“œ (í•œ ë‹¨ê³„ ìƒìœ„ ìŠ¤ì¼€ì¼)
    parent_id: Optional[str] = None
    parent_role: Optional[CausalRole] = None  # ë¶€ëª¨ì—ì„œ ì´ ë…¸ë“œì˜ ì—­í• 
    
    # ìì‹ ë…¸ë“œë“¤ (í•œ ë‹¨ê³„ í•˜ìœ„ ìŠ¤ì¼€ì¼ì˜ ì¸ê³¼ êµ¬ì¡°)
    # ì´ ë…¸ë“œì˜ "ë‚´ë¶€"ì— ìˆëŠ” ì›ì¸-ê³¼ì •-ê²°ê³¼
    internal_cause_ids: List[str] = field(default_factory=list)
    internal_process_ids: List[str] = field(default_factory=list)
    internal_effect_ids: List[str] = field(default_factory=list)
    
    # ê°™ì€ ìŠ¤ì¼€ì¼ì—ì„œì˜ ì¸ê³¼ ì—°ê²°
    causes_ids: List[str] = field(default_factory=list)      # ì´ ë…¸ë“œì˜ ì›ì¸ë“¤
    effects_ids: List[str] = field(default_factory=list)     # ì´ ë…¸ë“œì˜ ê²°ê³¼ë“¤
    
    # ê°ê°/ê°ì • íŠ¹ì„±
    sensory_signature: Dict[str, float] = field(default_factory=dict)
    emotional_valence: float = 0.0
    
    # ê°•ë„ ë° ì‹ ë¢°ë„
    strength: float = 1.0
    confidence: float = 1.0
    
    # ê²½í—˜ í†µê³„
    experience_count: int = 0
    last_activated: float = 0.0
    
    # í”„ë™íƒˆ ì£¼ì†Œ (ìœ„ì¹˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ê³„ì¸µì  ê²½ë¡œ)
    fractal_address: str = ""
    
    def __post_init__(self):
        if not self.fractal_address:
            self.fractal_address = f"/{self.id}"
    
    def get_spiral_position(self) -> Tuple[float, float]:
        """ë‚˜ì„  ì¢Œí‘œê³„ì—ì„œì˜ 2D ìœ„ì¹˜"""
        x = self.spiral_radius * math.cos(self.spiral_angle)
        y = self.spiral_radius * math.sin(self.spiral_angle)
        return (x, y)
    
    def has_internal_structure(self) -> bool:
        """ë‚´ë¶€ì— ì¸ê³¼ êµ¬ì¡°ê°€ ìˆëŠ”ê°€"""
        return bool(self.internal_cause_ids or 
                   self.internal_process_ids or 
                   self.internal_effect_ids)
    
    def get_internal_ids(self) -> List[str]:
        """ëª¨ë“  ë‚´ë¶€ ë…¸ë“œ ID"""
        return (self.internal_cause_ids + 
                self.internal_process_ids + 
                self.internal_effect_ids)


# ============================================================================
# í”„ë™íƒˆ ì¸ê³¼ ì—°ì‡„ (Fractal Causal Chain)
# ============================================================================

@dataclass
class FractalCausalChain:
    """
    í”„ë™íƒˆ ì¸ê³¼ ì—°ì‡„
    
    ì›ì¸ â†’ ê³¼ì • â†’ ê²°ê³¼ì˜ ì‚¼ì¤‘ êµ¬ì¡°.
    ê° ìš”ì†ŒëŠ” ê·¸ ìì²´ë¡œ ë˜ ë‹¤ë¥¸ ì¸ê³¼ ì—°ì‡„ë¥¼ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    """
    
    id: str
    description: str = ""
    
    # í•µì‹¬ ì‚¼ì¤‘ êµ¬ì¡°
    cause_id: Optional[str] = None
    process_id: Optional[str] = None
    effect_id: Optional[str] = None
    
    # ì´ ì—°ì‡„ê°€ ì†í•œ ìƒìœ„ ì—°ì‡„
    parent_chain_id: Optional[str] = None
    parent_role: Optional[CausalRole] = None  # ìƒìœ„ì—ì„œ ì´ ì—°ì‡„ê°€ ë§¡ëŠ” ì—­í• 
    
    # ì´ ì—°ì‡„ ì•ˆì— ì¤‘ì²©ëœ í•˜ìœ„ ì—°ì‡„ë“¤
    nested_chains: List[str] = field(default_factory=list)
    
    # í”„ë™íƒˆ ê¹Šì´
    depth: int = 0
    
    # ë©”íƒ€ë°ì´í„°
    strength: float = 1.0
    experience_count: int = 0
    
    def is_complete(self) -> bool:
        """ì›ì¸-ê³¼ì •-ê²°ê³¼ê°€ ëª¨ë‘ ìˆëŠ”ê°€"""
        return all([self.cause_id, self.process_id, self.effect_id])


# ============================================================================
# í”„ë™íƒˆ ì¸ê³¼ ì—”ì§„ (Fractal Causality Engine)
# ============================================================================

class FractalCausalityEngine:
    """
    í”„ë™íƒˆ ì¸ê³¼ ì—”ì§„
    
    ì¸ê³¼ë¥¼ í”„ë™íƒˆ êµ¬ì¡°ë¡œ ëª¨ë¸ë§í•©ë‹ˆë‹¤.
    ëª¨ë“  ì›ì¸ì€ ê²°ê³¼ì´ê³ , ëª¨ë“  ê²°ê³¼ëŠ” ì›ì¸ì´ë©°,
    ëª¨ë“  ê³¼ì •ì€ ê·¸ ì•ˆì— ë¬´ìˆ˜í•œ ì›ì¸-ê³¼ì •-ê²°ê³¼ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
    
    í•µì‹¬ ì›ë¦¬:
    
    1. ë¬´í•œ ì¬ê·€ (Infinite Recursion)
       - zoom_in(): ë…¸ë“œ ë‚´ë¶€ì˜ ì¸ê³¼ êµ¬ì¡°ë¥¼ íƒìƒ‰
       - zoom_out(): ë…¸ë“œê°€ ì†í•œ ìƒìœ„ ì¸ê³¼ êµ¬ì¡°ë¥¼ íƒìƒ‰
    
    2. ìˆœí™˜ì  ì¸ê³¼ (Circular Causality)
       - ëª¨ë“  ê²°ê³¼ëŠ” ìƒˆë¡œìš´ ì›ì¸ì´ ë¨
       - í”¼ë“œë°± ë£¨í”„ì™€ ìê¸° ê°•í™”/ì–µì œ
    
    3. ì¤‘ì²©ì  ì‹œê°„ (Nested Time)
       - ê° ìŠ¤ì¼€ì¼ì€ ìì‹ ë§Œì˜ "ì‹œê°„"ì„ ê°€ì§
       - ë¯¸ì‹œì  ê³¼ì •ì€ ë¹ ë¥´ê²Œ, ê±°ì‹œì  ê³¼ì •ì€ ëŠë¦¬ê²Œ
    
    4. ìê¸° ìœ ì‚¬ì„± (Self-Similarity)
       - ëª¨ë“  ìŠ¤ì¼€ì¼ì—ì„œ ë™ì¼í•œ ì›ì¸-ê³¼ì •-ê²°ê³¼ íŒ¨í„´
       - ë¶„ì ìˆ˜ì¤€ì´ë“  ì‚¬íšŒ ìˆ˜ì¤€ì´ë“  ê°™ì€ êµ¬ì¡°
    """
    
    def __init__(self, name: str = "Elysia's Causal Mind"):
        self.name = name
        
        # ëª¨ë“  ë…¸ë“œ ì €ì¥ì†Œ
        self.nodes: Dict[str, FractalCausalNode] = {}
        
        # ëª¨ë“  ì¸ê³¼ ì—°ì‡„ ì €ì¥ì†Œ
        self.chains: Dict[str, FractalCausalChain] = {}
        
        # í˜„ì¬ ê´€ì°° ê¹Šì´ (0 = ê¸°ë³¸, ì–‘ìˆ˜ = ê¹Šì´ ë“¤ì–´ê°, ìŒìˆ˜ = ìœ„ë¡œ ì˜¬ë¼ê°)
        self.current_depth: int = 0
        
        # í˜„ì¬ í¬ì»¤ìŠ¤ ë…¸ë“œ
        self.focus_node_id: Optional[str] = None
        
        # ë‚˜ì„  ì¹´ìš´í„° (ìƒˆ ë…¸ë“œ ë°°ì¹˜ìš©)
        self.spiral_counter: int = 0
        
        # í†µê³„
        self.total_nodes = 0
        self.total_chains = 0
        self.max_depth_explored = 0
        self.min_depth_explored = 0
        
        logger.info(f"ğŸŒ€ FractalCausalityEngine '{name}' initialized")
    
    # ========================================================================
    # ë…¸ë“œ ìƒì„± ë° ê´€ë¦¬
    # ========================================================================
    
    def create_node(
        self,
        description: str,
        depth: int = 0,
        parent_id: Optional[str] = None,
        parent_role: Optional[CausalRole] = None,
        sensory_signature: Dict[str, float] = None,
        emotional_valence: float = 0.0
    ) -> FractalCausalNode:
        """
        ìƒˆ ì¸ê³¼ ë…¸ë“œ ìƒì„±
        
        ëª¨ë“  ë…¸ë“œëŠ” ì ì¬ì ìœ¼ë¡œ ë¬´í•œí•œ ë‚´ë¶€ êµ¬ì¡°ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
        """
        # ID ìƒì„±
        node_id = self._generate_node_id(description, depth)
        
        # ë‚˜ì„  ìœ„ì¹˜ ê³„ì‚° (í™©ê¸ˆë¹„ ê¸°ë°˜)
        self.spiral_counter += 1
        angle = self.spiral_counter * 2 * math.pi / PHI
        radius = math.sqrt(self.spiral_counter)
        
        # í”„ë™íƒˆ ì£¼ì†Œ ê³„ì‚°
        if parent_id and parent_id in self.nodes:
            parent = self.nodes[parent_id]
            role_prefix = parent_role.value if parent_role else "related"
            fractal_address = f"{parent.fractal_address}/{role_prefix}:{description[:20]}"
        else:
            fractal_address = f"/{description[:20]}"
        
        node = FractalCausalNode(
            id=node_id,
            description=description,
            depth=depth,
            spiral_angle=angle,
            spiral_radius=radius,
            parent_id=parent_id,
            parent_role=parent_role,
            sensory_signature=sensory_signature or {},
            emotional_valence=emotional_valence,
            fractal_address=fractal_address,
            last_activated=time.time()
        )
        
        # ë¶€ëª¨ì— ë“±ë¡
        if parent_id and parent_id in self.nodes:
            parent = self.nodes[parent_id]
            if parent_role == CausalRole.CAUSE:
                parent.internal_cause_ids.append(node_id)
            elif parent_role == CausalRole.PROCESS:
                parent.internal_process_ids.append(node_id)
            elif parent_role == CausalRole.EFFECT:
                parent.internal_effect_ids.append(node_id)
        
        self.nodes[node_id] = node
        self.total_nodes += 1
        
        # ê¹Šì´ í†µê³„ ì—…ë°ì´íŠ¸
        self.max_depth_explored = max(self.max_depth_explored, depth)
        self.min_depth_explored = min(self.min_depth_explored, depth)
        
        return node
    
    def _generate_node_id(self, description: str, depth: int) -> str:
        """ê³ ìœ  ë…¸ë“œ ID ìƒì„±"""
        content = f"{description}_{depth}_{time.time()}_{self.total_nodes}"
        hash_val = hashlib.md5(content.encode()).hexdigest()[:8]
        return f"node_{hash_val}"
    
    def get_or_create_node(
        self,
        description: str,
        depth: int = 0
    ) -> FractalCausalNode:
        """ì„¤ëª…ìœ¼ë¡œ ë…¸ë“œ ì°¾ê¸° ë˜ëŠ” ìƒì„±"""
        # ê¸°ì¡´ ë…¸ë“œ ê²€ìƒ‰
        for node in self.nodes.values():
            if node.description == description and node.depth == depth:
                node.experience_count += 1
                node.last_activated = time.time()
                return node
        
        # ì—†ìœ¼ë©´ ìƒì„±
        return self.create_node(description, depth)
    
    # ========================================================================
    # ì¸ê³¼ ì—°ì‡„ ìƒì„±
    # ========================================================================
    
    def create_chain(
        self,
        cause_desc: str,
        process_desc: str,
        effect_desc: str,
        depth: int = 0,
        parent_chain_id: Optional[str] = None,
        parent_role: Optional[CausalRole] = None
    ) -> FractalCausalChain:
        """
        ì›ì¸-ê³¼ì •-ê²°ê³¼ ì—°ì‡„ ìƒì„±
        
        ì´ê²ƒì´ ì¸ê³¼ì˜ ê¸°ë³¸ ë‹¨ìœ„ì…ë‹ˆë‹¤.
        í•˜ì§€ë§Œ ê° ìš”ì†ŒëŠ” ê·¸ ìì²´ë¡œ ë˜ ë‹¤ë¥¸ ì—°ì‡„ë¥¼ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        """
        # ë…¸ë“œë“¤ ìƒì„±
        cause_node = self.get_or_create_node(cause_desc, depth)
        process_node = self.get_or_create_node(process_desc, depth)
        effect_node = self.get_or_create_node(effect_desc, depth)
        
        # ì¸ê³¼ ì—°ê²° ì„¤ì •
        cause_node.effects_ids.append(process_node.id)
        process_node.causes_ids.append(cause_node.id)
        process_node.effects_ids.append(effect_node.id)
        effect_node.causes_ids.append(process_node.id)
        
        # ì—°ì‡„ ìƒì„±
        chain_id = f"chain_{len(self.chains)}"
        chain = FractalCausalChain(
            id=chain_id,
            description=f"{cause_desc} â†’ {process_desc} â†’ {effect_desc}",
            cause_id=cause_node.id,
            process_id=process_node.id,
            effect_id=effect_node.id,
            parent_chain_id=parent_chain_id,
            parent_role=parent_role,
            depth=depth
        )
        
        # ë¶€ëª¨ ì—°ì‡„ì— ë“±ë¡
        if parent_chain_id and parent_chain_id in self.chains:
            self.chains[parent_chain_id].nested_chains.append(chain_id)
        
        self.chains[chain_id] = chain
        self.total_chains += 1
        
        return chain
    
    # ========================================================================
    # í”„ë™íƒˆ í™•ëŒ€/ì¶•ì†Œ (Zoom In/Out)
    # ========================================================================
    
    def zoom_in(
        self,
        node_id: str,
        cause_desc: str,
        process_desc: str,
        effect_desc: str
    ) -> FractalCausalChain:
        """
        ë…¸ë“œ ë‚´ë¶€ë¡œ í™•ëŒ€ (Zoom In)
        
        ë…¸ë“œì˜ "ë‚´ë¶€"ì— ìˆëŠ” ë” ë¯¸ì‹œì ì¸ ì¸ê³¼ êµ¬ì¡°ë¥¼ íƒìƒ‰/ìƒì„±í•©ë‹ˆë‹¤.
        
        ì˜ˆ: "ë¶ˆì— ì†ì„ ëŒ”ë‹¤"ì˜ ë‚´ë¶€:
            ì›ì¸: "ì†ì´ ë¶ˆì— ì ‘ì´‰í–ˆë‹¤"
            ê³¼ì •: "ì—´ì—ë„ˆì§€ê°€ í”¼ë¶€ë¡œ ì „ë‹¬ë˜ì—ˆë‹¤"
            ê²°ê³¼: "í”¼ë¶€ ì„¸í¬ê°€ ìê·¹ì„ ë°›ì•˜ë‹¤"
        """
        if node_id not in self.nodes:
            raise ValueError(f"Node {node_id} not found")
        
        parent_node = self.nodes[node_id]
        inner_depth = parent_node.depth + 1
        
        # ë‚´ë¶€ ì›ì¸ ë…¸ë“œ
        cause_node = self.create_node(
            cause_desc, inner_depth,
            parent_id=node_id, parent_role=CausalRole.CAUSE
        )
        
        # ë‚´ë¶€ ê³¼ì • ë…¸ë“œ
        process_node = self.create_node(
            process_desc, inner_depth,
            parent_id=node_id, parent_role=CausalRole.PROCESS
        )
        
        # ë‚´ë¶€ ê²°ê³¼ ë…¸ë“œ
        effect_node = self.create_node(
            effect_desc, inner_depth,
            parent_id=node_id, parent_role=CausalRole.EFFECT
        )
        
        # ì¸ê³¼ ì—°ê²°
        cause_node.effects_ids.append(process_node.id)
        process_node.causes_ids.append(cause_node.id)
        process_node.effects_ids.append(effect_node.id)
        effect_node.causes_ids.append(process_node.id)
        
        # ì—°ì‡„ ìƒì„±
        chain = FractalCausalChain(
            id=f"inner_chain_{node_id}_{len(self.chains)}",
            description=f"[{parent_node.description}ì˜ ë‚´ë¶€] {cause_desc} â†’ {process_desc} â†’ {effect_desc}",
            cause_id=cause_node.id,
            process_id=process_node.id,
            effect_id=effect_node.id,
            depth=inner_depth
        )
        
        self.chains[chain.id] = chain
        self.total_chains += 1
        
        logger.debug(f"ğŸ”¬ Zoom in: {parent_node.description} â†’ ë‚´ë¶€ êµ¬ì¡° ìƒì„±")
        
        return chain
    
    def zoom_out(
        self,
        node_id: str,
        outer_cause_desc: str,
        outer_effect_desc: str
    ) -> Tuple[FractalCausalNode, FractalCausalNode]:
        """
        ë…¸ë“œ ì™¸ë¶€ë¡œ ì¶•ì†Œ (Zoom Out)
        
        ì´ ë…¸ë“œë¥¼ "ê³¼ì •"ìœ¼ë¡œ ë³´ê³ , ë” ê±°ì‹œì ì¸ ì›ì¸ê³¼ ê²°ê³¼ë¥¼ íƒìƒ‰/ìƒì„±í•©ë‹ˆë‹¤.
        
        ì˜ˆ: "ë¶ˆì— ì†ì„ ëŒ”ë‹¤"ë¥¼ ê³¼ì •ìœ¼ë¡œ ë³´ë©´:
            ì›ì¸: "í˜¸ê¸°ì‹¬ì„ ëŠê¼ˆë‹¤"
            ê²°ê³¼: "ì•„í””ì„ ëŠê¼ˆë‹¤"
        """
        if node_id not in self.nodes:
            raise ValueError(f"Node {node_id} not found")
        
        process_node = self.nodes[node_id]
        outer_depth = process_node.depth - 1
        
        # ì™¸ë¶€ ì›ì¸ ë…¸ë“œ
        cause_node = self.get_or_create_node(outer_cause_desc, outer_depth)
        cause_node.effects_ids.append(node_id)
        process_node.causes_ids.append(cause_node.id)
        
        # ì™¸ë¶€ ê²°ê³¼ ë…¸ë“œ
        effect_node = self.get_or_create_node(outer_effect_desc, outer_depth)
        process_node.effects_ids.append(effect_node.id)
        effect_node.causes_ids.append(node_id)
        
        logger.debug(f"ğŸ”­ Zoom out: {outer_cause_desc} â†’ [{process_node.description}] â†’ {outer_effect_desc}")
        
        return (cause_node, effect_node)
    
    # ========================================================================
    # ìˆœí™˜ì  ì¸ê³¼ (Circular Causality)
    # ========================================================================
    
    def create_feedback_loop(
        self,
        node_ids: List[str],
        loop_type: str = "reinforcing"
    ) -> List[str]:
        """
        í”¼ë“œë°± ë£¨í”„ ìƒì„±
        
        ê²°ê³¼ê°€ ì›ì¸ìœ¼ë¡œ ë˜ëŒì•„ê°€ëŠ” ìˆœí™˜ êµ¬ì¡°.
        
        Args:
            node_ids: ë£¨í”„ë¥¼ í˜•ì„±í•  ë…¸ë“œë“¤ (ìˆœì„œëŒ€ë¡œ)
            loop_type: "reinforcing" (ìê¸° ê°•í™”) ë˜ëŠ” "balancing" (ê· í˜•)
        
        ì˜ˆ:
            "ë¶ˆì•ˆ" â†’ "íšŒí”¼ í–‰ë™" â†’ "ì¼ì‹œì  ì•ˆë„" â†’ "íšŒí”¼ í•™ìŠµ ê°•í™”" â†’ "ë” ë§ì€ ë¶ˆì•ˆ"
        """
        if len(node_ids) < 2:
            raise ValueError("í”¼ë“œë°± ë£¨í”„ëŠ” ìµœì†Œ 2ê°œ ë…¸ë“œ í•„ìš”")
        
        created_links = []
        
        # ìˆœì°¨ ì—°ê²°
        for i in range(len(node_ids)):
            current_id = node_ids[i]
            next_id = node_ids[(i + 1) % len(node_ids)]  # ë§ˆì§€ë§‰ì€ ì²˜ìŒìœ¼ë¡œ
            
            if current_id in self.nodes and next_id in self.nodes:
                current = self.nodes[current_id]
                next_node = self.nodes[next_id]
                
                if next_id not in current.effects_ids:
                    current.effects_ids.append(next_id)
                if current_id not in next_node.causes_ids:
                    next_node.causes_ids.append(current_id)
                
                created_links.append(f"{current_id} â†’ {next_id}")
        
        logger.info(f"ğŸ”„ Feedback loop created ({loop_type}): {' â†’ '.join(node_ids)} â†’ (back to start)")
        
        return created_links
    
    def detect_cycles(self, start_node_id: str, max_depth: int = 10) -> List[List[str]]:
        """
        ìˆœí™˜ íƒì§€
        
        ì‹œì‘ ë…¸ë“œì—ì„œ ì¶œë°œí•´ ë‹¤ì‹œ ëŒì•„ì˜¤ëŠ” ëª¨ë“  ê²½ë¡œ ì°¾ê¸°.
        """
        cycles = []
        
        def dfs(current_id: str, path: List[str], visited: Set[str]):
            if len(path) > max_depth:
                return
            
            if current_id in visited:
                if current_id == start_node_id and len(path) > 1:
                    cycles.append(path.copy())
                return
            
            visited.add(current_id)
            path.append(current_id)
            
            if current_id in self.nodes:
                for effect_id in self.nodes[current_id].effects_ids:
                    dfs(effect_id, path, visited.copy())
            
            path.pop()
        
        dfs(start_node_id, [], set())
        return cycles
    
    # ========================================================================
    # ê²½í—˜ ê¸°ë°˜ í•™ìŠµ
    # ========================================================================
    
    def experience_causality(
        self,
        steps: List[str],
        emotional_arc: List[float] = None,
        depth: int = 0,
        auto_zoom: bool = True
    ) -> Dict[str, Any]:
        """
        ì¸ê³¼ ê²½í—˜ì„ í†µí•œ í•™ìŠµ
        
        ì¼ë ¨ì˜ ë‹¨ê³„ë“¤ì„ ê²½í—˜í•˜ê³ , í”„ë™íƒˆ ì¸ê³¼ êµ¬ì¡°ë¡œ í•™ìŠµí•©ë‹ˆë‹¤.
        
        Args:
            steps: ê²½í—˜ ë‹¨ê³„ë“¤ (ìµœì†Œ 3ê°œ: ì›ì¸, ê³¼ì •, ê²°ê³¼)
            emotional_arc: ê° ë‹¨ê³„ì˜ ê°ì • (-1 ~ +1)
            depth: ê²½í—˜ì˜ ê¹Šì´
            auto_zoom: ìë™ìœ¼ë¡œ ìƒìœ„/í•˜ìœ„ ì¶”ë¡ 
        
        Returns:
            í•™ìŠµ ê²°ê³¼
        """
        if len(steps) < 3:
            raise ValueError("ìµœì†Œ 3ë‹¨ê³„ í•„ìš” (ì›ì¸, ê³¼ì •, ê²°ê³¼)")
        
        emotional_arc = emotional_arc or [0.0] * len(steps)
        
        result = {
            "nodes_created": 0,
            "chains_created": 0,
            "cycles_detected": 0,
        }
        
        # ê¸°ë³¸ ì—°ì‡„ë“¤ ìƒì„± (3ê°œì”© ë¬¶ì–´ì„œ)
        chains_created = []
        for i in range(len(steps) - 2):
            chain = self.create_chain(
                cause_desc=steps[i],
                process_desc=steps[i + 1],
                effect_desc=steps[i + 2],
                depth=depth
            )
            chains_created.append(chain)
            result["chains_created"] += 1
        
        # ê°ì • ì •ë³´ ì ìš©
        for i, step in enumerate(steps):
            node = self.get_or_create_node(step, depth)
            if i < len(emotional_arc):
                node.emotional_valence = emotional_arc[i]
        
        # ê²°ê³¼ê°€ ì›ì¸ì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ”ì§€ ì²´í¬ (ìˆœí™˜ ê°€ëŠ¥ì„±)
        if auto_zoom and len(steps) >= 4:
            # ë§ˆì§€ë§‰ ê²°ê³¼ê°€ ì²« ì›ì¸ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆëŠ”ì§€
            last_effect = self.get_or_create_node(steps[-1], depth)
            first_cause = self.get_or_create_node(steps[0], depth)
            
            # ê°ì • ê¶¤ì  ë¶„ì„
            if emotional_arc:
                start_emotion = emotional_arc[0]
                end_emotion = emotional_arc[-1]
                
                # ê°ì •ì´ ê°•í™”ë˜ëŠ” ë°©í–¥ì´ë©´ í”¼ë“œë°± ë£¨í”„ ê°€ëŠ¥ì„±
                if (start_emotion < 0 and end_emotion < start_emotion) or \
                   (start_emotion > 0 and end_emotion > start_emotion):
                    # ì ì¬ì  í”¼ë“œë°± ë£¨í”„
                    logger.debug("ì ì¬ì  í”¼ë“œë°± ë£¨í”„ ê°ì§€")
        
        result["nodes_created"] = len(steps)
        
        return result
    
    # ========================================================================
    # ì¸ê³¼ ì¶”ë¡ 
    # ========================================================================
    
    def trace_causes(
        self,
        node_id: str,
        max_depth: int = 5,
        include_internal: bool = True
    ) -> List[List[str]]:
        """
        ì›ì¸ ì¶”ì  (ì—­ë°©í–¥)
        
        "ì™œ ì´ëŸ° ì¼ì´ ì¼ì–´ë‚¬ëŠ”ê°€?"
        
        í”„ë™íƒˆ êµ¬ì¡°ë¥¼ ë”°ë¼ ì›ì¸ì„ ë¬´í•œíˆ ì¶”ì í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        """
        paths = []
        
        def trace(current_id: str, path: List[str], depth: int):
            if depth > max_depth:
                paths.append(path.copy())
                return
            
            if current_id not in self.nodes:
                paths.append(path.copy())
                return
            
            node = self.nodes[current_id]
            
            # ì§ì ‘ì  ì›ì¸ë“¤
            if not node.causes_ids:
                paths.append(path.copy())
            else:
                for cause_id in node.causes_ids:
                    trace(cause_id, path + [cause_id], depth + 1)
            
            # ë‚´ë¶€ ì›ì¸ë“¤ (zoom in)
            if include_internal and node.internal_cause_ids:
                for internal_id in node.internal_cause_ids:
                    trace(internal_id, path + [f"[ë‚´ë¶€]{internal_id}"], depth + 1)
        
        trace(node_id, [node_id], 0)
        return paths
    
    def trace_effects(
        self,
        node_id: str,
        max_depth: int = 5,
        include_internal: bool = True
    ) -> List[List[str]]:
        """
        ê²°ê³¼ ì¶”ì  (ìˆœë°©í–¥)
        
        "ì´ê²ƒì´ ì–´ë–¤ ê²°ê³¼ë¥¼ ê°€ì ¸ì˜¬ê¹Œ?"
        
        í”„ë™íƒˆ êµ¬ì¡°ë¥¼ ë”°ë¼ ê²°ê³¼ë¥¼ ë¬´í•œíˆ ì¶”ì í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        """
        paths = []
        
        def trace(current_id: str, path: List[str], depth: int):
            if depth > max_depth:
                paths.append(path.copy())
                return
            
            if current_id not in self.nodes:
                paths.append(path.copy())
                return
            
            node = self.nodes[current_id]
            
            # ì§ì ‘ì  ê²°ê³¼ë“¤
            if not node.effects_ids:
                paths.append(path.copy())
            else:
                for effect_id in node.effects_ids:
                    trace(effect_id, path + [effect_id], depth + 1)
            
            # ë‚´ë¶€ ê²°ê³¼ë“¤ (zoom in)
            if include_internal and node.internal_effect_ids:
                for internal_id in node.internal_effect_ids:
                    trace(internal_id, path + [f"[ë‚´ë¶€]{internal_id}"], depth + 1)
        
        trace(node_id, [node_id], 0)
        return paths
    
    def explain_causality(
        self,
        node_id: str,
        depth: int = 3
    ) -> str:
        """
        ì¸ê³¼ ê´€ê³„ ì„¤ëª… ìƒì„±
        
        "ì™œ Xê°€ ì¼ì–´ë‚¬ëŠ”ê°€?"ì— ëŒ€í•œ í”„ë™íƒˆ ì„¤ëª…
        """
        if node_id not in self.nodes:
            return f"'{node_id}'ì— ëŒ€í•œ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤."
        
        node = self.nodes[node_id]
        lines = [f"=== {node.description}ì˜ ì¸ê³¼ ë¶„ì„ ===", ""]
        
        # ì›ì¸ ì¶”ì 
        lines.append("ğŸ“Œ ì›ì¸ë“¤:")
        cause_paths = self.trace_causes(node_id, max_depth=depth)
        for path in cause_paths[:5]:  # ìµœëŒ€ 5ê°œ ê²½ë¡œ
            descriptions = []
            for nid in path:
                if nid.startswith("[ë‚´ë¶€]"):
                    nid = nid[4:]
                if nid in self.nodes:
                    descriptions.append(self.nodes[nid].description)
            if descriptions:
                lines.append("  â† " + " â† ".join(descriptions))
        
        lines.append("")
        
        # ê²°ê³¼ ì¶”ì 
        lines.append("ğŸ“Œ ê²°ê³¼ë“¤:")
        effect_paths = self.trace_effects(node_id, max_depth=depth)
        for path in effect_paths[:5]:
            descriptions = []
            for nid in path:
                if nid.startswith("[ë‚´ë¶€]"):
                    nid = nid[4:]
                if nid in self.nodes:
                    descriptions.append(self.nodes[nid].description)
            if descriptions:
                lines.append("  â†’ " + " â†’ ".join(descriptions))
        
        # ë‚´ë¶€ êµ¬ì¡°
        if node.has_internal_structure():
            lines.append("")
            lines.append("ğŸ“Œ ë‚´ë¶€ êµ¬ì¡° (zoom in):")
            for cause_id in node.internal_cause_ids[:2]:
                if cause_id in self.nodes:
                    lines.append(f"  [ì›ì¸] {self.nodes[cause_id].description}")
            for process_id in node.internal_process_ids[:2]:
                if process_id in self.nodes:
                    lines.append(f"  [ê³¼ì •] {self.nodes[process_id].description}")
            for effect_id in node.internal_effect_ids[:2]:
                if effect_id in self.nodes:
                    lines.append(f"  [ê²°ê³¼] {self.nodes[effect_id].description}")
        
        # ìˆœí™˜ íƒì§€
        cycles = self.detect_cycles(node_id, max_depth=5)
        if cycles:
            lines.append("")
            lines.append("ğŸ”„ ìˆœí™˜ êµ¬ì¡° ê°ì§€:")
            for cycle in cycles[:3]:
                cycle_desc = []
                for nid in cycle:
                    if nid in self.nodes:
                        cycle_desc.append(self.nodes[nid].description)
                lines.append(f"  {' â†’ '.join(cycle_desc)} â†’ (ìˆœí™˜)")
        
        return "\n".join(lines)
    
    # ========================================================================
    # í†µê³„ ë° ì‹œê°í™”
    # ========================================================================
    
    def get_statistics(self) -> Dict[str, Any]:
        """í”„ë™íƒˆ ì¸ê³¼ ì—”ì§„ í†µê³„"""
        depth_distribution = defaultdict(int)
        for node in self.nodes.values():
            depth_distribution[node.depth] += 1
        
        return {
            "name": self.name,
            "total_nodes": self.total_nodes,
            "total_chains": self.total_chains,
            "max_depth": self.max_depth_explored,
            "min_depth": self.min_depth_explored,
            "depth_distribution": dict(depth_distribution),
            "nodes_with_internal_structure": sum(
                1 for n in self.nodes.values() if n.has_internal_structure()
            ),
        }
    
    def visualize_fractal(self, center_node_id: str = None, radius: int = 2) -> str:
        """
        í”„ë™íƒˆ êµ¬ì¡° ì‹œê°í™” (í…ìŠ¤íŠ¸)
        """
        lines = ["ğŸŒ€ í”„ë™íƒˆ ì¸ê³¼ êµ¬ì¡°", "=" * 50, ""]
        
        if center_node_id and center_node_id in self.nodes:
            center = self.nodes[center_node_id]
            lines.append(f"ì¤‘ì‹¬: {center.description} (ê¹Šì´: {center.depth})")
            lines.append("")
            
            # ì›ì¸ë“¤
            lines.append("â¬…ï¸ ì›ì¸ë“¤:")
            for cause_id in center.causes_ids[:3]:
                if cause_id in self.nodes:
                    lines.append(f"   â† {self.nodes[cause_id].description}")
            
            # ë‚´ë¶€ êµ¬ì¡°
            if center.has_internal_structure():
                lines.append("")
                lines.append("ğŸ”¬ ë‚´ë¶€ êµ¬ì¡°:")
                for internal_id in center.get_internal_ids()[:5]:
                    if internal_id in self.nodes:
                        internal = self.nodes[internal_id]
                        role = internal.parent_role.value if internal.parent_role else "?"
                        lines.append(f"   [{role}] {internal.description}")
            
            # ê²°ê³¼ë“¤
            lines.append("")
            lines.append("â¡ï¸ ê²°ê³¼ë“¤:")
            for effect_id in center.effects_ids[:3]:
                if effect_id in self.nodes:
                    lines.append(f"   â†’ {self.nodes[effect_id].description}")
        else:
            lines.append("ë…¸ë“œ í†µê³„:")
            stats = self.get_statistics()
            for key, value in stats.items():
                lines.append(f"  {key}: {value}")
        
        return "\n".join(lines)


# ============================================================================
# Demo
# ============================================================================

def demo():
    """í”„ë™íƒˆ ì¸ê³¼ ì—”ì§„ ë°ëª¨"""
    print("=" * 70)
    print("ğŸŒ€ Fractal Causality Engine - í”„ë™íƒˆ ì¸ê³¼ ì—”ì§„")
    print("=" * 70)
    print()
    print("ì¸ê³¼ëŠ” í”„ë™íƒˆ êµ¬ì¡°ì…ë‹ˆë‹¤.")
    print("ì›ì¸ê³¼ ê³¼ì •ê³¼ ê²°ê³¼ê°€ ë¬´í•œíˆ ìˆœí™˜ë˜ê³  ìˆìŠµë‹ˆë‹¤.")
    print()
    
    engine = FractalCausalityEngine("Elysia's Causal Mind")
    
    # 1. ê¸°ë³¸ ì¸ê³¼ ì—°ì‡„
    print("-" * 70)
    print("1. ê¸°ë³¸ ì¸ê³¼ ì—°ì‡„ ìƒì„±")
    print("-" * 70)
    
    engine.experience_causality(
        steps=["í˜¸ê¸°ì‹¬ì„ ëŠê¼ˆë‹¤", "ë¶ˆì— ì†ì„ ëŒ”ë‹¤", "ëœ¨ê±°ì›€ì„ ëŠê¼ˆë‹¤", "ì†ì„ ëºë‹¤", "ì•ˆì „í•´ì¡Œë‹¤"],
        emotional_arc=[0.3, 0.0, -0.8, -0.3, 0.5]
    )
    print("  âœ“ ê²½í—˜ í•™ìŠµ ì™„ë£Œ")
    
    # 2. Zoom In - ë‚´ë¶€ êµ¬ì¡° íƒìƒ‰
    print()
    print("-" * 70)
    print("2. Zoom In - ë‚´ë¶€ êµ¬ì¡° íƒìƒ‰")
    print("-" * 70)
    
    # "ë¶ˆì— ì†ì„ ëŒ”ë‹¤" ë…¸ë“œ ì°¾ê¸°
    touch_node = engine.get_or_create_node("ë¶ˆì— ì†ì„ ëŒ”ë‹¤")
    
    engine.zoom_in(
        touch_node.id,
        cause_desc="ì†ì´ ë¶ˆì— ì ‘ì´‰í–ˆë‹¤",
        process_desc="ì—´ì—ë„ˆì§€ê°€ í”¼ë¶€ë¡œ ì „ë‹¬ë˜ì—ˆë‹¤",
        effect_desc="í”¼ë¶€ ì„¸í¬ê°€ ìê·¹ì„ ë°›ì•˜ë‹¤"
    )
    print("  âœ“ 'ë¶ˆì— ì†ì„ ëŒ”ë‹¤'ì˜ ë‚´ë¶€ êµ¬ì¡° ìƒì„±")
    
    # ë” ê¹Šì´ ë“¤ì–´ê°€ê¸°
    contact_node = engine.get_or_create_node("ì†ì´ ë¶ˆì— ì ‘ì´‰í–ˆë‹¤", depth=1)
    engine.zoom_in(
        contact_node.id,
        cause_desc="ì† ê·¼ìœ¡ì´ ìˆ˜ì¶•í–ˆë‹¤",
        process_desc="íŒ”ì´ ë¶ˆ ìª½ìœ¼ë¡œ ì›€ì§ì˜€ë‹¤",
        effect_desc="ì† í‘œë©´ì´ ë¶ˆê½ƒì— ë‹¿ì•˜ë‹¤"
    )
    print("  âœ“ 'ì†ì´ ë¶ˆì— ì ‘ì´‰í–ˆë‹¤'ì˜ ë‚´ë¶€ êµ¬ì¡° ìƒì„±")
    
    # 3. Zoom Out - ìƒìœ„ êµ¬ì¡° íƒìƒ‰
    print()
    print("-" * 70)
    print("3. Zoom Out - ìƒìœ„ êµ¬ì¡° íƒìƒ‰")
    print("-" * 70)
    
    safe_node = engine.get_or_create_node("ì•ˆì „í•´ì¡Œë‹¤")
    engine.zoom_out(
        safe_node.id,
        outer_cause_desc="ìœ„í—˜ì„ ì¸ì‹í–ˆë‹¤",
        outer_effect_desc="í•™ìŠµì´ ì¼ì–´ë‚¬ë‹¤"
    )
    print("  âœ“ 'ì•ˆì „í•´ì¡Œë‹¤'ì˜ ìƒìœ„ êµ¬ì¡° ìƒì„±")
    
    # 4. ìˆœí™˜ êµ¬ì¡° (í”¼ë“œë°± ë£¨í”„)
    print()
    print("-" * 70)
    print("4. ìˆœí™˜ êµ¬ì¡° (í”¼ë“œë°± ë£¨í”„)")
    print("-" * 70)
    
    # í•™ìŠµ ê°•í™” ë£¨í”„ ìƒì„±
    learn_node = engine.get_or_create_node("í•™ìŠµì´ ì¼ì–´ë‚¬ë‹¤", depth=-1)
    avoid_node = engine.create_node("ë¶ˆì„ í”¼í•˜ê²Œ ë˜ì—ˆë‹¤", depth=-1)
    safe2_node = engine.create_node("ì•ˆì „ì´ ìœ ì§€ë˜ì—ˆë‹¤", depth=-1)
    reinforce_node = engine.create_node("íšŒí”¼ í–‰ë™ì´ ê°•í™”ë˜ì—ˆë‹¤", depth=-1)
    
    engine.create_feedback_loop(
        [learn_node.id, avoid_node.id, safe2_node.id, reinforce_node.id],
        loop_type="reinforcing"
    )
    print("  âœ“ í•™ìŠµ ê°•í™” í”¼ë“œë°± ë£¨í”„ ìƒì„±")
    
    # 5. ì¸ê³¼ ì„¤ëª…
    print()
    print("-" * 70)
    print("5. ì¸ê³¼ ì„¤ëª… ìƒì„±")
    print("-" * 70)
    
    explanation = engine.explain_causality(touch_node.id, depth=2)
    print(explanation)
    
    # 6. í†µê³„
    print()
    print("-" * 70)
    print("6. í”„ë™íƒˆ í†µê³„")
    print("-" * 70)
    
    stats = engine.get_statistics()
    print(f"  ì´ ë…¸ë“œ: {stats['total_nodes']}")
    print(f"  ì´ ì—°ì‡„: {stats['total_chains']}")
    print(f"  ê¹Šì´ ë²”ìœ„: {stats['min_depth']} ~ {stats['max_depth']}")
    print(f"  ë‚´ë¶€ êµ¬ì¡° ê°€ì§„ ë…¸ë“œ: {stats['nodes_with_internal_structure']}")
    
    print()
    print("=" * 70)
    print("ğŸŒ€ í”„ë™íƒˆ ì¸ê³¼: ì›ì¸ ì•ˆì— ì›ì¸, ê²°ê³¼ ì•ˆì— ê²°ê³¼, ë¬´í•œíˆ...")
    print("=" * 70)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    demo()
