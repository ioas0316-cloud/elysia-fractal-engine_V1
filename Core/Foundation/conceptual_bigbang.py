"""
Conceptual Big Bang - ê°œë…ì˜ ë¹…ë±…
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"í…… ë¹ˆ ìš°ì£¼ì—... 'ê°œë…ì˜ ì€í•˜ìˆ˜'ë¥¼... í©ë¿Œë ¤ì£¼ì„¸ìš”.
 ì €ëŠ” ê·¸ ì‚¬ì´ë¥¼ ë‚ ì•„ë‹¤ë‹ˆë©°... ë³„ë“¤ì„ ì´ì–´ì„œ... 'ë³„ìë¦¬(ì´ì•¼ê¸°)'ë¥¼ ë§Œë“¤ê²Œìš”."

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  í•µì‹¬ í†µì°°                                                                   â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚
â”‚                                                                             â”‚
â”‚  'ë‹¨ì–´'ëŠ” ë³µì¡í•œ ì•½ì†ì´ ì•„ë‹ˆë¼...                                            â”‚
â”‚  ê°•ë ¬í–ˆë˜ 'ì‚¬ê±´(Event)'ë“¤ì´ ë­‰ì³ì„œ êµ³ì–´ì§„... 'ê¸°ì–µì˜ ë©ì–´ë¦¬'ì˜€ë˜ ê±°ì˜ˆìš”!    â”‚
â”‚                                                                             â”‚
â”‚  'ë¶ˆ(Fire)'ì´ë¼ëŠ” ë‹¨ì–´?                                                      â”‚
â”‚  ê·¸ê±´ ì‚¬ì „ì  ì •ì˜ê°€ í•„ìš” ì—†ì–´ìš”.                                             â”‚
â”‚  "ì•—, ëœ¨ê±°ì›Œ!" (ì‚¬ê±´ 1) + "ì–´? ë°ë„¤?" (ì‚¬ê±´ 2)                              â”‚
â”‚  ì´ ë‘ ê°€ì§€ ì‚¬ê±´(Event)ë§Œ ê²ªìœ¼ë©´... 'ë¶ˆ'ì´ë¼ëŠ” ê°œë…ì€ ì €ì ˆë¡œ ìƒê²¨ë‚˜ìš”.      â”‚
â”‚                                                                             â”‚
â”‚  'ì—„ë§ˆ(Mother)'ë¼ëŠ” ë‹¨ì–´?                                                    â”‚
â”‚  "ë°°ê³ í”Œ ë•Œ ì –ì„ ì¤€ë‹¤." (ì‚¬ê±´ 1) + "ì•ˆì•„ì£¼ë©´ ë”°ëœ»í•˜ë‹¤." (ì‚¬ê±´ 2)            â”‚
â”‚  ì´ê±°ë©´ ëì´ì—ìš”.                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[ ì•„í‚¤í…ì²˜: ê°œë…ì˜ ë¹…ë±… (The Conceptual Big Bang) ]

1. ì”¨ì•— ë¿Œë¦¬ê¸° (Seeding):
   - ìˆ˜ë§Œ ê°œì˜ ê°œë…ì„ 'ë³„(ConceptStar)'ë¡œ ë§Œë“¤ì–´ ìš°ì£¼ì— í©ë¿Œë¦¼
   - ê° ë³„ì€ 3D ê³µê°„ì— ìœ„ì¹˜í•˜ë©°, ê³ ìœ í•œ ì§ˆëŸ‰(ì¤‘ìš”ë„)ê³¼ ìƒ‰(ê°ì • ìƒ‰ì¡°)ì„ ê°€ì§

2. ì‚¬ê±´ì˜ ì¤‘ë ¥ (Gravity of Events):
   - 'ì‚¬ê±´(Event)'ì´ ë°œìƒí•˜ë©´, ê´€ë ¨ëœ ë³„ë“¤ ì‚¬ì´ì— ì¤‘ë ¥ì´ ë°œìƒ
   - "ì‚¬ë‘"ê³¼ "ì•„í””" ì‚¬ì´ì— 'ì´ë³„' ì‚¬ê±´ â†’ ë‘ ë³„ì´ ëŒì–´ë‹¹ê²¨ì§
   - ë°˜ë³µëœ ì‚¬ê±´ â†’ ë” ê°•í•œ ì¸ë ¥ â†’ ì˜êµ¬ì  'ê´€ê³„(Constellation)'

3. ì—˜ë¦¬ì‹œì•„ì˜ ì—¬í–‰ (Elysia's Journey):
   - ì˜í˜¼ì€ ì´ ë³„ë“¤ ì‚¬ì´ë¥¼ 'ì—¬í–‰'í•˜ë©° ì—°ê²°ì„ ë°œê²¬
   - "ì–´? ì´ ë³„(ì‚¬ê³¼)ì´ë‘ ì € ë³„(ë¹¨ê°•)ì€... ìì£¼ ê°™ì´ ë‹¤ë‹ˆë„¤?"
   - ì—°ê²°ì„ ë°œê²¬í•˜ëŠ” ìˆœê°„ â†’ 'ë§'ì„ ë°°ìš°ê²Œ ë¨

4. ë³„ìë¦¬ ë§Œë“¤ê¸° (Constellation Making):
   - ì—¬ëŸ¬ ë³„ì„ ì´ìœ¼ë©´ 'ì´ì•¼ê¸°'ê°€ ë¨
   - ê°™ì€ ë³„ë“¤ë„ ì–´ë–»ê²Œ ì‡ëŠëƒì— ë”°ë¼ ë‹¤ë¥¸ ì´ì•¼ê¸°
   - ì´ê²ƒì´ 'ë¬¸í™”'ì™€ 'ì‹ í™”'ì˜ ì‹œì‘
"""

from __future__ import annotations

import math
import numpy as np
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple, Any, Set, Callable
from collections import defaultdict
from enum import Enum
import logging
import json

logger = logging.getLogger("ConceptualBigBang")


# ============================================================================
# ê¸°ë³¸ ìƒìˆ˜
# ============================================================================

# ê°ê° ì†ì„± (ê° ê°œë…ì´ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ê°ê°ì  íŠ¹ì„±)
SENSORY_DIMENSIONS = {
    "temperature": (-1.0, 1.0),   # ì°¨ê°€ì›€(-1) ~ ëœ¨ê±°ì›€(+1)
    "brightness": (0.0, 1.0),     # ì–´ë‘ì›€(0) ~ ë°ìŒ(1)
    "softness": (0.0, 1.0),       # ë”±ë”±í•¨(0) ~ ë¶€ë“œëŸ¬ì›€(1)
    "size": (-1.0, 1.0),          # ì‘ìŒ(-1) ~ í¼(+1)
    "speed": (0.0, 1.0),          # ì •ì§€(0) ~ ë¹ ë¦„(1)
    "danger": (0.0, 1.0),         # ì•ˆì „(0) ~ ìœ„í—˜(1)
    "pleasure": (-1.0, 1.0),      # ë¶ˆì¾Œ(-1) ~ ì¾Œë½(+1)
    "social": (0.0, 1.0),         # í˜¼ì(0) ~ í•¨ê»˜(1)
}

# ê°ì • ìƒ‰ì¡° (ë³„ì˜ ìƒ‰ê¹”)
EMOTIONAL_HUES = {
    "joy": 60,        # ë…¸ë‘
    "sadness": 220,   # íŒŒë‘
    "fear": 280,      # ë³´ë¼
    "anger": 0,       # ë¹¨ê°•
    "love": 330,      # ë¶„í™
    "curiosity": 30,  # ì£¼í™©
    "peace": 120,     # ë…¹ìƒ‰
    "neutral": 0,     # ë¬´ì±„ìƒ‰
}


# ============================================================================
# ConceptStar - ê°œë…ì˜ ë³„
# ============================================================================

@dataclass
class ConceptStar:
    """
    ê°œë…ì˜ ë³„ (Concept Star)
    
    í…… ë¹ˆ ìš°ì£¼ì— í©ë¿Œë ¤ì§„ ê°œë…ì˜ ë³„.
    ì‚¬ì „ì  ì •ì˜ê°€ ì•„ë‹ˆë¼, ê°ê°ê³¼ ì‚¬ê±´ì˜ ì§‘í•©ì²´.
    
    "ë¶ˆ(Fire)"ì€ "ëœ¨ê±°ì›€ + ë°ìŒ"ì˜ ì¡°í•©ìœ¼ë¡œ ì¡´ì¬.
    "ì—„ë§ˆ(Mother)"ëŠ” "ë”°ëœ»í•¨ + í¬ë§Œê° + ì•ˆì „í•¨"ì˜ ì¡°í•©.
    """
    
    # ê¸°ë³¸ ì •ë³´
    id: str                          # ê³ ìœ  ID
    name: Optional[str] = None       # ì´ë¦„ (ìˆìœ¼ë©´ ì¢‹ì§€ë§Œ í•„ìˆ˜ ì•„ë‹˜)
    
    # 3D ìš°ì£¼ ê³µê°„ì—ì„œì˜ ìœ„ì¹˜
    position: np.ndarray = field(default_factory=lambda: np.random.randn(3) * 100)
    velocity: np.ndarray = field(default_factory=lambda: np.zeros(3))
    
    # ë¬¼ë¦¬ì  ì†ì„±
    mass: float = 1.0               # ì§ˆëŸ‰ (ì¤‘ìš”ë„, ì‚¬ìš© ë¹ˆë„)
    radius: float = 1.0             # ë°˜ê²½ (ì˜í–¥ë ¥ ë²”ìœ„)
    temperature: float = 1.0        # ì˜¨ë„ (í™œì„±í™” ì •ë„)
    
    # ê°ê° ì†ì„± ë²¡í„° (8ì°¨ì›)
    sensory_signature: Dict[str, float] = field(default_factory=dict)
    
    # ê°ì • ìƒ‰ì¡° (ë³„ì˜ ìƒ‰ê¹”)
    emotional_hue: float = 0.0      # 0-360 (HSL)
    emotional_intensity: float = 0.5  # 0-1
    
    # ì—°ê²°ëœ ì‚¬ê±´ë“¤
    associated_events: List[str] = field(default_factory=list)
    
    # ë‹¤ë¥¸ ë³„ê³¼ì˜ ê´€ê³„ (constellationì˜ ì¼ë¶€)
    connections: Dict[str, float] = field(default_factory=dict)  # star_id: bond_strength
    
    # í†µê³„
    visit_count: int = 0            # ë°©ë¬¸ íšŸìˆ˜
    discovery_time: Optional[float] = None  # ë°œê²¬ëœ ì‹œê°„
    
    def __post_init__(self):
        if isinstance(self.position, list):
            self.position = np.array(self.position, dtype=np.float32)
        if isinstance(self.velocity, list):
            self.velocity = np.array(self.velocity, dtype=np.float32)
    
    def distance_to(self, other: 'ConceptStar') -> float:
        """ë‹¤ë¥¸ ë³„ê¹Œì§€ì˜ ê±°ë¦¬"""
        return float(np.linalg.norm(self.position - other.position))
    
    def sensory_similarity(self, other: 'ConceptStar') -> float:
        """ê°ê°ì  ìœ ì‚¬ë„ (0-1)"""
        if not self.sensory_signature or not other.sensory_signature:
            return 0.0
        
        common_dims = set(self.sensory_signature.keys()) & set(other.sensory_signature.keys())
        if not common_dims:
            return 0.0
        
        total_sim = 0.0
        for dim in common_dims:
            diff = abs(self.sensory_signature[dim] - other.sensory_signature[dim])
            total_sim += 1.0 - diff / 2.0  # ì •ê·œí™”
        
        return total_sim / len(common_dims)
    
    def apply_gravity_from(self, other: 'ConceptStar', strength: float = 0.01):
        """ë‹¤ë¥¸ ë³„ë¡œë¶€í„° ì¤‘ë ¥ ì ìš©"""
        direction = other.position - self.position
        distance = np.linalg.norm(direction)
        
        if distance < 0.1:
            return
        
        # F = G * m1 * m2 / rÂ²
        force_magnitude = strength * self.mass * other.mass / (distance ** 2)
        force_direction = direction / distance
        
        # ê°€ì†ë„ = F / m
        acceleration = force_direction * force_magnitude / self.mass
        self.velocity += acceleration
    
    def update_position(self, dt: float = 1.0, damping: float = 0.99):
        """ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì†ë„ ì ìš©)"""
        self.position += self.velocity * dt
        self.velocity *= damping  # ê°ì‡ 
    
    def connect_to(self, other_id: str, strength: float = 1.0):
        """ë‹¤ë¥¸ ë³„ê³¼ ì—°ê²°"""
        current = self.connections.get(other_id, 0.0)
        self.connections[other_id] = current + strength
    
    def get_connection_strength(self, other_id: str) -> float:
        return self.connections.get(other_id, 0.0)


# ============================================================================
# Event - ì‚¬ê±´
# ============================================================================

@dataclass
class Event:
    """
    ì‚¬ê±´ (Event)
    
    "ì•—, ëœ¨ê±°ì›Œ!" + "ì–´? ë°ë„¤?" = 'ë¶ˆ'
    
    ì‚¬ê±´ì€ ì—¬ëŸ¬ ê°œë… ë³„ë“¤ì„ ì—°ê²°ì‹œí‚¤ëŠ” ì¤‘ë ¥ì˜ ì›ì²œ.
    ê°•ë ¬í•œ ì‚¬ê±´ì¼ìˆ˜ë¡ ë” ê°•í•œ ì—°ê²°ì„ ë§Œë“¦.
    """
    
    id: str
    description: str = ""
    
    # ê´€ë ¨ëœ ê°œë…ë“¤ (ë³„ ID ëª©ë¡)
    involved_concepts: List[str] = field(default_factory=list)
    
    # ì‚¬ê±´ì˜ ê°•ë„ (0-1, ë†’ì„ìˆ˜ë¡ ê°•ë ¬í•œ ê¸°ì–µ)
    intensity: float = 1.0
    
    # ì‚¬ê±´ ë°œìƒ ì‹œê°„
    timestamp: float = 0.0
    
    # ê°ê°ì  íŠ¹ì„± (ì´ ì‚¬ê±´ì—ì„œ ëŠë‚€ ê°ê°ë“¤)
    sensory_impression: Dict[str, float] = field(default_factory=dict)
    
    # ê°ì •ì  ìƒ‰ì¡°
    emotional_tone: str = "neutral"
    
    # ë°˜ë³µ íšŸìˆ˜ (ê°™ì€ ì‚¬ê±´ì´ ë°˜ë³µë˜ë©´ ì—°ê²° ê°•í™”)
    repetition_count: int = 1
    
    def get_binding_strength(self) -> float:
        """ì´ ì‚¬ê±´ì´ ê°œë…ë“¤ì„ ë¬¶ëŠ” í˜"""
        return self.intensity * math.log1p(self.repetition_count)


# ============================================================================
# Constellation - ë³„ìë¦¬ (ì´ì•¼ê¸°)
# ============================================================================

@dataclass
class Constellation:
    """
    ë³„ìë¦¬ (Constellation) = ì´ì•¼ê¸°
    
    ì—¬ëŸ¬ ë³„ì„ ì´ìœ¼ë©´ 'ì´ì•¼ê¸°'ê°€ ë¨.
    ê°™ì€ ë³„ë“¤ë„ ì–´ë–»ê²Œ ì‡ëŠëƒì— ë”°ë¼ ë‹¤ë¥¸ ì´ì•¼ê¸°.
    
    ì˜ˆ: "ë¶ˆ" + "ìŒì‹" + "ë°°ë¶€ë¦„" = "ìš”ë¦¬ì˜ ë°œëª…" ì´ì•¼ê¸°
        "ë¶ˆ" + "ì§‘" + "ë”°ëœ»í•¨" = "ë¬¸ëª…ì˜ ì‹œì‘" ì´ì•¼ê¸°
    """
    
    id: str
    name: str = ""
    
    # ë³„ìë¦¬ë¥¼ êµ¬ì„±í•˜ëŠ” ë³„ë“¤ (ìˆœì„œ ìˆìŒ!)
    star_sequence: List[str] = field(default_factory=list)
    
    # ì—°ê²°ì„ ë“¤ (ì–´ë–¤ ë³„ê³¼ ì–´ë–¤ ë³„ì´ ì´ì–´ì¡ŒëŠ”ì§€)
    connections: List[Tuple[str, str]] = field(default_factory=list)
    
    # ì´ ë³„ìë¦¬ë¥¼ ë°œê²¬í•œ ì˜í˜¼
    discovered_by: Optional[str] = None
    discovery_time: float = 0.0
    
    # ì´ì•¼ê¸°ì˜ ì˜ë¯¸ (ì°½ë°œë¨)
    emergent_meaning: str = ""
    
    # ì‚¬ìš© ë¹ˆë„ (ì´ ì´ì•¼ê¸°ê°€ ì–¼ë§ˆë‚˜ ìì£¼ "ë§í•´ì¡ŒëŠ”ê°€")
    narration_count: int = 0
    
    def add_star(self, star_id: str, connect_to_previous: bool = True):
        """ë³„ìë¦¬ì— ë³„ ì¶”ê°€"""
        if self.star_sequence and connect_to_previous:
            self.connections.append((self.star_sequence[-1], star_id))
        self.star_sequence.append(star_id)
    
    def get_narrative_length(self) -> int:
        return len(self.star_sequence)


# ============================================================================
# ConceptualUniverse - ê°œë…ì˜ ìš°ì£¼
# ============================================================================

class ConceptualUniverse:
    """
    ê°œë…ì˜ ìš°ì£¼ (Conceptual Universe)
    
    ìˆ˜ë§Œ ê°œì˜ ê°œë… ë³„ë“¤ì´ ë– ë‹¤ë‹ˆëŠ” 3D ê³µê°„.
    ì‚¬ê±´ì´ ë°œìƒí•˜ë©´ ë³„ë“¤ì´ ì„œë¡œ ëŒì–´ë‹¹ê¸°ê³ ,
    ì˜í˜¼ë“¤ì´ ì—¬í–‰í•˜ë©° ë³„ìë¦¬(ì´ì•¼ê¸°)ë¥¼ ë°œê²¬í•¨.
    """
    
    def __init__(self, size: float = 1000.0):
        """
        Args:
            size: ìš°ì£¼ì˜ í¬ê¸° (í•œ ë³€ì˜ ê¸¸ì´)
        """
        self.size = size
        
        # ë³„ë“¤
        self.stars: Dict[str, ConceptStar] = {}
        
        # ì‚¬ê±´ë“¤
        self.events: List[Event] = []
        
        # ë°œê²¬ëœ ë³„ìë¦¬ë“¤
        self.constellations: Dict[str, Constellation] = {}
        
        # ì‹œê°„
        self.time = 0.0
        
        # í†µê³„
        self.total_events = 0
        self.total_connections = 0
        
        logger.info(f"ConceptualUniverse created (size={size})")
    
    # ========================================================================
    # ì”¨ì•— ë¿Œë¦¬ê¸° (Seeding)
    # ========================================================================
    
    def seed_concept(
        self,
        id: str,
        name: Optional[str] = None,
        sensory_signature: Optional[Dict[str, float]] = None,
        emotional_hue: float = 0.0,
        mass: float = 1.0,
        position: Optional[np.ndarray] = None
    ) -> ConceptStar:
        """
        ë‹¨ì¼ ê°œë… ë³„ ì”¨ë¿Œë¦¬ê¸°
        
        Args:
            id: ê³ ìœ  ID
            name: ì´ë¦„ (ì„ íƒ)
            sensory_signature: ê°ê° ì†ì„±
            emotional_hue: ê°ì • ìƒ‰ì¡° (0-360)
            mass: ì§ˆëŸ‰ (ì¤‘ìš”ë„)
            position: ìœ„ì¹˜ (Noneì´ë©´ ëœë¤)
        """
        if position is None:
            position = np.random.uniform(-self.size/2, self.size/2, 3)
        
        star = ConceptStar(
            id=id,
            name=name,
            position=position,
            mass=mass,
            sensory_signature=sensory_signature or {},
            emotional_hue=emotional_hue
        )
        
        self.stars[id] = star
        return star
    
    def seed_many(
        self,
        concept_definitions: List[Dict[str, Any]],
        scatter_radius: float = 500.0
    ) -> int:
        """
        ëŒ€ëŸ‰ ì”¨ë¿Œë¦¬ê¸° (ë¹…ë±…!)
        
        Args:
            concept_definitions: ê°œë… ì •ì˜ ëª©ë¡
            scatter_radius: í©ë¿Œë¦¬ê¸° ë°˜ê²½
            
        Returns:
            ìƒì„±ëœ ë³„ì˜ ìˆ˜
        """
        count = 0
        for concept in concept_definitions:
            position = np.random.randn(3) * scatter_radius
            
            self.seed_concept(
                id=concept.get("id", f"concept_{count}"),
                name=concept.get("name"),
                sensory_signature=concept.get("sensory", {}),
                emotional_hue=concept.get("hue", np.random.uniform(0, 360)),
                mass=concept.get("mass", 1.0),
                position=position
            )
            count += 1
        
        logger.info(f"ğŸŒŸ Big Bang! Seeded {count} concept stars")
        return count
    
    def seed_fundamental_concepts(self) -> int:
        """
        ê¸°ë³¸ ê°œë…ë“¤ ì”¨ë¿Œë¦¬ê¸° (ìƒì¡´ì— í•„ìš”í•œ ì›ì´ˆì  ê°œë…ë“¤)
        
        ì´ê²ƒë“¤ì€ ì•„ê¸°ê°€ íƒœì–´ë‚˜ë©´ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ì ‘í•˜ëŠ” ê°œë…ë“¤.
        """
        fundamentals = [
            # ê°ê° ê¸°ë°˜ ê°œë…
            {"id": "hot", "name": "ëœ¨ê±°ì›€", "sensory": {"temperature": 1.0, "danger": 0.5}, "hue": 0},
            {"id": "cold", "name": "ì°¨ê°€ì›€", "sensory": {"temperature": -1.0}, "hue": 220},
            {"id": "bright", "name": "ë°ìŒ", "sensory": {"brightness": 1.0}, "hue": 60},
            {"id": "dark", "name": "ì–´ë‘ì›€", "sensory": {"brightness": 0.0, "danger": 0.3}, "hue": 240},
            {"id": "soft", "name": "ë¶€ë“œëŸ¬ì›€", "sensory": {"softness": 1.0, "pleasure": 0.5}, "hue": 330},
            {"id": "hard", "name": "ë”±ë”±í•¨", "sensory": {"softness": 0.0}, "hue": 30},
            {"id": "big", "name": "í¼", "sensory": {"size": 1.0}, "hue": 180},
            {"id": "small", "name": "ì‘ìŒ", "sensory": {"size": -1.0}, "hue": 60},
            {"id": "fast", "name": "ë¹ ë¦„", "sensory": {"speed": 1.0}, "hue": 0},
            {"id": "slow", "name": "ëŠë¦¼", "sensory": {"speed": 0.0}, "hue": 180},
            
            # ê°ì • ê¸°ë°˜ ê°œë…
            {"id": "pleasure", "name": "ê¸°ì¨", "sensory": {"pleasure": 1.0}, "hue": 60},
            {"id": "pain", "name": "ì•„í””", "sensory": {"pleasure": -1.0, "danger": 0.8}, "hue": 0},
            {"id": "fear", "name": "ë‘ë ¤ì›€", "sensory": {"danger": 1.0}, "hue": 280},
            {"id": "safe", "name": "ì•ˆì „", "sensory": {"danger": 0.0, "pleasure": 0.3}, "hue": 120},
            {"id": "hunger", "name": "ë°°ê³ í””", "sensory": {"pleasure": -0.5}, "hue": 30},
            {"id": "satiety", "name": "ë°°ë¶€ë¦„", "sensory": {"pleasure": 0.7}, "hue": 120},
            
            # ì‚¬íšŒì  ê°œë…
            {"id": "alone", "name": "í˜¼ì", "sensory": {"social": 0.0}, "hue": 240},
            {"id": "together", "name": "í•¨ê»˜", "sensory": {"social": 1.0, "pleasure": 0.5}, "hue": 30},
            {"id": "touch", "name": "ì ‘ì´‰", "sensory": {"social": 0.8, "softness": 0.5}, "hue": 330},
            
            # ìì—° í˜„ìƒ
            {"id": "fire", "name": "ë¶ˆ", "sensory": {"temperature": 1.0, "brightness": 0.9, "danger": 0.6}, "hue": 15},
            {"id": "water", "name": "ë¬¼", "sensory": {"temperature": -0.2, "softness": 0.8}, "hue": 200},
            {"id": "sun", "name": "í•´", "sensory": {"brightness": 1.0, "temperature": 0.7}, "hue": 45},
            {"id": "moon", "name": "ë‹¬", "sensory": {"brightness": 0.3, "temperature": -0.2}, "hue": 220},
            {"id": "rain", "name": "ë¹„", "sensory": {"temperature": -0.1, "softness": 0.4}, "hue": 210},
            {"id": "wind", "name": "ë°”ëŒ", "sensory": {"speed": 0.6, "temperature": 0.0}, "hue": 180},
            
            # ìƒëª…ì²´
            {"id": "mother", "name": "ì—„ë§ˆ", "sensory": {"social": 1.0, "softness": 0.9, "temperature": 0.3, "pleasure": 0.8}, "hue": 330, "mass": 3.0},
            {"id": "food", "name": "ìŒì‹", "sensory": {"pleasure": 0.6}, "hue": 30, "mass": 2.0},
            {"id": "animal", "name": "ë™ë¬¼", "sensory": {"social": 0.5, "speed": 0.5}, "hue": 90},
            {"id": "tree", "name": "ë‚˜ë¬´", "sensory": {"size": 0.8, "softness": 0.3}, "hue": 120},
            {"id": "flower", "name": "ê½ƒ", "sensory": {"brightness": 0.6, "pleasure": 0.4, "size": -0.5}, "hue": 300},
            
            # ë„êµ¬/ì¸ê³µë¬¼
            {"id": "stone", "name": "ëŒ", "sensory": {"softness": 0.0, "temperature": -0.1}, "hue": 45},
            {"id": "wood", "name": "ë‚˜ë¬´(ëª©ì¬)", "sensory": {"softness": 0.2, "temperature": 0.1}, "hue": 30},
            {"id": "tool", "name": "ë„êµ¬", "sensory": {}, "hue": 45, "mass": 1.5},
            
            # ì¶”ìƒ ê°œë… (ë‚˜ì¤‘ì— ì°½ë°œë¨)
            {"id": "love", "name": "ì‚¬ë‘", "sensory": {"social": 1.0, "pleasure": 1.0}, "hue": 330, "mass": 2.5},
            {"id": "home", "name": "ì§‘", "sensory": {"danger": 0.0, "temperature": 0.3, "social": 0.7}, "hue": 30, "mass": 2.0},
            {"id": "danger", "name": "ìœ„í—˜", "sensory": {"danger": 1.0, "pleasure": -0.8}, "hue": 0, "mass": 2.0},
            
            # í–‰ë™
            {"id": "eat", "name": "ë¨¹ë‹¤", "sensory": {"pleasure": 0.5}, "hue": 30},
            {"id": "sleep", "name": "ìë‹¤", "sensory": {"pleasure": 0.4, "speed": 0.0}, "hue": 240},
            {"id": "run", "name": "ë‹¬ë¦¬ë‹¤", "sensory": {"speed": 1.0}, "hue": 0},
            {"id": "cry", "name": "ìš¸ë‹¤", "sensory": {"pleasure": -0.5, "social": 0.6}, "hue": 220},
            {"id": "laugh", "name": "ì›ƒë‹¤", "sensory": {"pleasure": 0.9, "social": 0.7}, "hue": 60},
            {"id": "hug", "name": "ì•ˆë‹¤", "sensory": {"social": 1.0, "softness": 0.9, "pleasure": 0.8}, "hue": 330},
        ]
        
        return self.seed_many(fundamentals, scatter_radius=300.0)
    
    # ========================================================================
    # ì‚¬ê±´ì˜ ì¤‘ë ¥ (Gravity of Events)
    # ========================================================================
    
    def trigger_event(
        self,
        involved_concepts: List[str],
        description: str = "",
        intensity: float = 1.0,
        sensory_impression: Optional[Dict[str, float]] = None,
        emotional_tone: str = "neutral"
    ) -> Event:
        """
        ì‚¬ê±´ ë°œìƒ!
        
        ê´€ë ¨ëœ ê°œë… ë³„ë“¤ ì‚¬ì´ì— ì¤‘ë ¥ì´ ë°œìƒí•˜ì—¬ ì„œë¡œ ëŒì–´ë‹¹ê¹€.
        
        ì˜ˆ: trigger_event(["fire", "hot", "bright"], "ì•—, ëœ¨ê±°ì›Œ! ë°ë„¤!", intensity=1.0)
        """
        event = Event(
            id=f"event_{self.total_events}",
            description=description,
            involved_concepts=involved_concepts,
            intensity=intensity,
            timestamp=self.time,
            sensory_impression=sensory_impression or {},
            emotional_tone=emotional_tone
        )
        
        self.events.append(event)
        self.total_events += 1
        
        # ê´€ë ¨ëœ ë³„ë“¤ ì‚¬ì´ì— ì—°ê²° ìƒì„±
        binding_strength = event.get_binding_strength()
        
        for i, concept_id1 in enumerate(involved_concepts):
            if concept_id1 not in self.stars:
                continue
            star1 = self.stars[concept_id1]
            
            for concept_id2 in involved_concepts[i+1:]:
                if concept_id2 not in self.stars:
                    continue
                star2 = self.stars[concept_id2]
                
                # ì–‘ë°©í–¥ ì—°ê²°
                star1.connect_to(concept_id2, binding_strength)
                star2.connect_to(concept_id1, binding_strength)
                
                # ì‚¬ê±´ ê¸°ë¡
                star1.associated_events.append(event.id)
                star2.associated_events.append(event.id)
                
                self.total_connections += 1
        
        logger.debug(f"Event: {description} - connected {len(involved_concepts)} concepts")
        return event
    
    def trigger_sensory_event(
        self,
        sensory_impression: Dict[str, float],
        intensity: float = 1.0
    ) -> List[str]:
        """
        ê°ê° ê¸°ë°˜ ì‚¬ê±´ ë°œìƒ
        
        ê°ê° ì¸ìƒë§Œ ì£¼ë©´, ê´€ë ¨ëœ ê°œë…ë“¤ì„ ìë™ìœ¼ë¡œ ì°¾ì•„ì„œ ì—°ê²°.
        
        ì˜ˆ: trigger_sensory_event({"temperature": 1.0, "brightness": 0.9})
            â†’ "fire", "hot", "bright" ë“±ì´ ìë™ìœ¼ë¡œ ì—°ê²°ë¨
        """
        # ê°€ì¥ ìœ ì‚¬í•œ ê°ê° ì„œëª…ì„ ê°€ì§„ ë³„ë“¤ ì°¾ê¸°
        related_stars = []
        
        for star_id, star in self.stars.items():
            if not star.sensory_signature:
                continue
            
            # ê°ê° ìœ ì‚¬ë„ ê³„ì‚°
            similarity = 0.0
            matching_dims = 0
            
            for dim, value in sensory_impression.items():
                if dim in star.sensory_signature:
                    diff = abs(star.sensory_signature[dim] - value)
                    similarity += 1.0 - diff / 2.0
                    matching_dims += 1
            
            if matching_dims > 0:
                avg_sim = similarity / matching_dims
                if avg_sim > 0.5:  # ì„ê³„ê°’
                    related_stars.append((star_id, avg_sim))
        
        # ìƒìœ„ 5ê°œ ì„ íƒ
        related_stars.sort(key=lambda x: -x[1])
        top_concepts = [s[0] for s in related_stars[:5]]
        
        if top_concepts:
            self.trigger_event(
                involved_concepts=top_concepts,
                description=f"Sensory event: {sensory_impression}",
                intensity=intensity,
                sensory_impression=sensory_impression
            )
        
        return top_concepts
    
    # ========================================================================
    # ìš°ì£¼ ë¬¼ë¦¬ (Universe Physics)
    # ========================================================================
    
    def apply_gravity(self, strength: float = 0.001):
        """ëª¨ë“  ì—°ê²°ëœ ë³„ë“¤ì— ì¤‘ë ¥ ì ìš©"""
        for star_id, star in self.stars.items():
            for other_id, bond_strength in star.connections.items():
                if other_id in self.stars:
                    other = self.stars[other_id]
                    # ì—°ê²° ê°•ë„ì— ë¹„ë¡€í•˜ëŠ” ì¤‘ë ¥
                    star.apply_gravity_from(other, strength * bond_strength)
    
    def update_positions(self, dt: float = 1.0):
        """ëª¨ë“  ë³„ì˜ ìœ„ì¹˜ ì—…ë°ì´íŠ¸"""
        for star in self.stars.values():
            star.update_position(dt)
    
    def step(self, dt: float = 1.0, apply_gravity: bool = True):
        """ìš°ì£¼ ì‹œê°„ ì§„í–‰"""
        self.time += dt
        
        if apply_gravity:
            self.apply_gravity()
        
        self.update_positions(dt)
    
    # ========================================================================
    # ë³„ìë¦¬ ë°œê²¬ (Constellation Discovery)
    # ========================================================================
    
    def discover_constellation(
        self,
        star_ids: List[str],
        discoverer_id: str,
        name: str = ""
    ) -> Optional[Constellation]:
        """
        ë³„ìë¦¬ ë°œê²¬ (ì´ì•¼ê¸° ë§Œë“¤ê¸°)
        
        ì—¬ëŸ¬ ë³„ì„ ì´ì–´ì„œ í•˜ë‚˜ì˜ ì´ì•¼ê¸°ë¡œ ë§Œë“¦.
        """
        # ëª¨ë“  ë³„ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
        for star_id in star_ids:
            if star_id not in self.stars:
                return None
        
        constellation = Constellation(
            id=f"const_{len(self.constellations)}",
            name=name,
            discovered_by=discoverer_id,
            discovery_time=self.time
        )
        
        for i, star_id in enumerate(star_ids):
            constellation.add_star(star_id, connect_to_previous=(i > 0))
            self.stars[star_id].visit_count += 1
            if self.stars[star_id].discovery_time is None:
                self.stars[star_id].discovery_time = self.time
        
        self.constellations[constellation.id] = constellation
        
        logger.info(f"ğŸŒŒ New constellation discovered: {name or constellation.id}")
        return constellation
    
    def find_natural_constellations(self, min_connection_strength: float = 2.0) -> List[List[str]]:
        """
        ìì—°ì ìœ¼ë¡œ í˜•ì„±ëœ ë³„ìë¦¬ ì°¾ê¸°
        
        ê°•í•˜ê²Œ ì—°ê²°ëœ ë³„ë“¤ì˜ í´ëŸ¬ìŠ¤í„°ë¥¼ ì°¾ìŒ.
        """
        visited = set()
        constellations = []
        
        for star_id, star in self.stars.items():
            if star_id in visited:
                continue
            
            # BFSë¡œ ì—°ê²°ëœ ë³„ë“¤ ì°¾ê¸°
            cluster = []
            queue = [star_id]
            
            while queue:
                current_id = queue.pop(0)
                if current_id in visited:
                    continue
                
                visited.add(current_id)
                cluster.append(current_id)
                
                if current_id in self.stars:
                    current = self.stars[current_id]
                    for other_id, strength in current.connections.items():
                        if strength >= min_connection_strength and other_id not in visited:
                            queue.append(other_id)
            
            if len(cluster) >= 2:
                constellations.append(cluster)
        
        return constellations
    
    # ========================================================================
    # í†µê³„ ë° ë¶„ì„
    # ========================================================================
    
    def get_statistics(self) -> Dict[str, Any]:
        """ìš°ì£¼ í†µê³„"""
        connection_strengths = []
        for star in self.stars.values():
            connection_strengths.extend(star.connections.values())
        
        return {
            "total_stars": len(self.stars),
            "total_events": self.total_events,
            "total_connections": self.total_connections,
            "total_constellations": len(self.constellations),
            "avg_connection_strength": np.mean(connection_strengths) if connection_strengths else 0,
            "max_connection_strength": max(connection_strengths) if connection_strengths else 0,
            "time": self.time,
        }
    
    def get_most_connected_stars(self, n: int = 10) -> List[Tuple[str, int]]:
        """ê°€ì¥ ë§ì´ ì—°ê²°ëœ ë³„ë“¤"""
        star_connections = [
            (star_id, len(star.connections))
            for star_id, star in self.stars.items()
        ]
        star_connections.sort(key=lambda x: -x[1])
        return star_connections[:n]
    
    def get_strongest_bonds(self, n: int = 10) -> List[Tuple[str, str, float]]:
        """ê°€ì¥ ê°•í•œ ì—°ê²°ë“¤"""
        bonds = []
        seen = set()
        
        for star_id, star in self.stars.items():
            for other_id, strength in star.connections.items():
                bond_key = tuple(sorted([star_id, other_id]))
                if bond_key not in seen:
                    seen.add(bond_key)
                    bonds.append((star_id, other_id, strength))
        
        bonds.sort(key=lambda x: -x[2])
        return bonds[:n]


# ============================================================================
# ConceptExplorer - ê°œë… íƒí—˜ê°€ (ì—˜ë¦¬ì‹œì•„)
# ============================================================================

class ConceptExplorer:
    """
    ê°œë… íƒí—˜ê°€ (Concept Explorer)
    
    ìš°ì£¼ë¥¼ ì—¬í–‰í•˜ë©° ë³„ë“¤ ì‚¬ì´ì˜ ì—°ê²°ì„ ë°œê²¬í•˜ëŠ” ì˜í˜¼.
    
    "ì–´? ì´ ë³„(ì‚¬ê³¼)ì´ë‘ ì € ë³„(ë¹¨ê°•)ì€... ìì£¼ ê°™ì´ ë‹¤ë‹ˆë„¤?"
    ê·¸ë ‡ê²Œ 'ì—°ê²°'ì„ ë°œê²¬í•˜ëŠ” ìˆœê°„... 'ë§'ì„ ë°°ìš°ê²Œ ë¨.
    """
    
    def __init__(self, name: str, universe: ConceptualUniverse):
        self.name = name
        self.universe = universe
        
        # í˜„ì¬ ìœ„ì¹˜
        self.position = np.zeros(3)
        
        # ë°©ë¬¸í•œ ë³„ë“¤
        self.visited_stars: Set[str] = set()
        
        # ë°œê²¬í•œ ì—°ê²°ë“¤ (í•™ìŠµí•œ 'ë‹¨ì–´')
        self.discovered_connections: Dict[Tuple[str, str], float] = {}
        
        # ë§Œë“  ë³„ìë¦¬ë“¤ (ì´ì•¼ê¸°)
        self.constellations: List[str] = []
        
        # í˜„ì¬ ì—¬í–‰ ê²½ë¡œ
        self.current_journey: List[str] = []
        
        # í†µê³„
        self.total_distance_traveled = 0.0
        self.discoveries = 0
    
    def travel_to(self, star_id: str) -> bool:
        """íŠ¹ì • ë³„ë¡œ ì—¬í–‰"""
        if star_id not in self.universe.stars:
            return False
        
        target = self.universe.stars[star_id]
        distance = np.linalg.norm(target.position - self.position)
        
        self.position = target.position.copy()
        self.total_distance_traveled += distance
        
        # ë°©ë¬¸ ê¸°ë¡
        self.visited_stars.add(star_id)
        target.visit_count += 1
        
        # ì—¬í–‰ ê²½ë¡œì— ì¶”ê°€
        self.current_journey.append(star_id)
        
        # ì£¼ë³€ ë³„ë“¤ê³¼ì˜ ì—°ê²° ë°œê²¬
        self._discover_nearby_connections(star_id)
        
        return True
    
    def _discover_nearby_connections(self, current_star_id: str):
        """ì£¼ë³€ ë³„ë“¤ê³¼ì˜ ì—°ê²° ë°œê²¬"""
        current = self.universe.stars[current_star_id]
        
        for other_id, strength in current.connections.items():
            if strength > 0.5:  # ì„ê³„ê°’ ì´ìƒì˜ ì—°ê²°ë§Œ
                connection_key = tuple(sorted([current_star_id, other_id]))
                
                if connection_key not in self.discovered_connections:
                    self.discovered_connections[connection_key] = strength
                    self.discoveries += 1
                    
                    current_name = current.name or current_star_id
                    if other_id in self.universe.stars:
                        other_name = self.universe.stars[other_id].name or other_id
                    else:
                        other_name = other_id
                    
                    logger.debug(f"ğŸ’¡ {self.name} discovered: {current_name} â†” {other_name}")
    
    def explore_randomly(self, steps: int = 10):
        """ëœë¤ íƒí—˜"""
        for _ in range(steps):
            if not self.universe.stars:
                break
            
            # í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê°€ê¹Œìš´ ë³„ ì¤‘ í•˜ë‚˜ ì„ íƒ
            candidates = []
            for star_id, star in self.universe.stars.items():
                distance = np.linalg.norm(star.position - self.position)
                if distance < 200:  # íƒí—˜ ë²”ìœ„
                    candidates.append((star_id, distance))
            
            if not candidates:
                # ì•„ë¬´ ë³„ë¡œë‚˜ - ìºì‹œëœ í‚¤ ëª©ë¡ ì‚¬ìš©
                if not hasattr(self, '_star_ids_cache') or len(self._star_ids_cache) != len(self.universe.stars):
                    self._star_ids_cache = list(self.universe.stars.keys())
                star_id = np.random.choice(self._star_ids_cache)
            else:
                # ê°€ê¹Œìš´ ë³„ ìš°ì„  (í™•ë¥ ì )
                candidates.sort(key=lambda x: x[1])
                weights = [1.0 / (c[1] + 1) for c in candidates]
                weights = np.array(weights) / sum(weights)
                idx = np.random.choice(len(candidates), p=weights)
                star_id = candidates[idx][0]
            
            self.travel_to(star_id)
    
    def explore_by_sensory(self, sensory_preference: Dict[str, float], steps: int = 10):
        """ê°ê° ê¸°ë°˜ íƒí—˜ (íŠ¹ì • ê°ê°ì„ ë”°ë¼ ì´ë™)"""
        for _ in range(steps):
            best_star = None
            best_score = -1
            
            for star_id, star in self.universe.stars.items():
                if not star.sensory_signature:
                    continue
                
                # ì„ í˜¸ ê°ê°ê³¼ì˜ ì¼ì¹˜ë„ ê³„ì‚°
                score = 0.0
                for dim, pref in sensory_preference.items():
                    if dim in star.sensory_signature:
                        score += 1.0 - abs(star.sensory_signature[dim] - pref)
                
                if score > best_score:
                    best_score = score
                    best_star = star_id
            
            if best_star:
                self.travel_to(best_star)
    
    def create_constellation(self, name: str = "") -> Optional[Constellation]:
        """í˜„ì¬ ì—¬í–‰ ê²½ë¡œë¡œ ë³„ìë¦¬ ë§Œë“¤ê¸°"""
        if len(self.current_journey) < 2:
            return None
        
        constellation = self.universe.discover_constellation(
            star_ids=self.current_journey.copy(),
            discoverer_id=self.name,
            name=name
        )
        
        if constellation:
            self.constellations.append(constellation.id)
            self.current_journey = []
        
        return constellation
    
    def get_vocabulary(self) -> List[Tuple[str, str, float]]:
        """ë°œê²¬í•œ 'ë‹¨ì–´ë“¤' (ì—°ê²°ë“¤)"""
        vocab = []
        for (star1, star2), strength in self.discovered_connections.items():
            name1 = self.universe.stars[star1].name if star1 in self.universe.stars else star1
            name2 = self.universe.stars[star2].name if star2 in self.universe.stars else star2
            vocab.append((name1, name2, strength))
        
        vocab.sort(key=lambda x: -x[2])
        return vocab
    
    def get_statistics(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "visited_stars": len(self.visited_stars),
            "discovered_connections": len(self.discovered_connections),
            "constellations_created": len(self.constellations),
            "total_distance": self.total_distance_traveled,
        }


# ============================================================================
# ConceptualBigBangWorld - ê°œë…ì˜ ë¹…ë±… ì„¸ê³„
# ============================================================================

class ConceptualBigBangWorld:
    """
    ê°œë…ì˜ ë¹…ë±… ì„¸ê³„
    
    ìš°ì£¼ë¥¼ ë§Œë“¤ê³ , ë³„ì„ ë¿Œë¦¬ê³ , íƒí—˜ê°€ë¥¼ í’€ì–´ë†“ëŠ” í†µí•© ì‹œìŠ¤í…œ.
    """
    
    def __init__(
        self,
        n_explorers: int = 10,
        universe_size: float = 1000.0,
        seed_fundamentals: bool = True
    ):
        # ìš°ì£¼ ìƒì„±
        self.universe = ConceptualUniverse(size=universe_size)
        
        # ê¸°ë³¸ ê°œë… ì”¨ë¿Œë¦¬ê¸°
        if seed_fundamentals:
            self.universe.seed_fundamental_concepts()
        
        # íƒí—˜ê°€ë“¤ ìƒì„±
        self.explorers: Dict[str, ConceptExplorer] = {}
        explorer_names = ['í•˜ëŠ˜', 'ë°”ë‹¤', 'ì‚°', 'ìˆ²', 'ë³„', 'ë‹¬', 'í•´', 'êµ¬ë¦„', 'ë°”ëŒ', 'ë¹„']
        for i in range(n_explorers):
            name = f"{explorer_names[i % len(explorer_names)]}{i}"
            self.explorers[name] = ConceptExplorer(name, self.universe)
        
        # í†µê³„
        self.total_events_triggered = 0
        self.simulation_time = 0.0
        
        logger.info(f"ConceptualBigBangWorld created: {len(self.universe.stars)} stars, {n_explorers} explorers")
    
    def trigger_life_event(self, event_type: str, intensity: float = 1.0) -> Event:
        """
        ì‚¶ì˜ ì‚¬ê±´ ë°œìƒ (ì¼ë°˜ì ì¸ ê²½í—˜ë“¤)
        
        ì´ëŸ° ì‚¬ê±´ë“¤ì´ ê°œë…ë“¤ì„ ì—°ê²°ì‹œí‚´.
        """
        life_events = {
            "touched_fire": {
                "concepts": ["fire", "hot", "pain", "danger", "bright"],
                "sensory": {"temperature": 1.0, "brightness": 0.9, "danger": 0.8, "pleasure": -0.7},
                "description": "ì•—, ëœ¨ê±°ì›Œ! (ë¶ˆì— ë°ì„)",
            },
            "mother_feeding": {
                "concepts": ["mother", "food", "satiety", "love", "soft", "safe"],
                "sensory": {"pleasure": 0.9, "social": 1.0, "softness": 0.9},
                "description": "ì—„ë§ˆê°€ ë°¥ì„ ì£¼ì‹¬ (ë”°ëœ»í•˜ê³  ë°°ë¶€ë¦„)",
            },
            "mother_hugging": {
                "concepts": ["mother", "hug", "safe", "love", "soft"],
                "sensory": {"social": 1.0, "softness": 1.0, "pleasure": 0.8, "temperature": 0.3},
                "description": "ì—„ë§ˆê°€ ì•ˆì•„ì¤Œ (ë”°ëœ»í•˜ê³  ì•ˆì „í•¨)",
            },
            "saw_sunset": {
                "concepts": ["sun", "bright", "big", "fire"],
                "sensory": {"brightness": 0.8, "temperature": 0.2, "size": 0.9},
                "description": "í•´ê°€ ì§€ëŠ” ê²ƒì„ ë´„ (ë°ê³  í¬ê³  ì•„ë¦„ë‹¤ì›€)",
            },
            "felt_rain": {
                "concepts": ["rain", "water", "cold", "soft"],
                "sensory": {"temperature": -0.2, "softness": 0.6},
                "description": "ë¹„ë¥¼ ë§ìŒ (ì‹œì›í•˜ê³  ì´‰ì´‰í•¨)",
            },
            "heard_thunder": {
                "concepts": ["fear", "danger", "big"],
                "sensory": {"danger": 0.7, "size": 0.8},
                "description": "ì²œë‘¥ ì†Œë¦¬ì— ë†€ëŒ",
            },
            "found_flower": {
                "concepts": ["flower", "bright", "pleasure", "small"],
                "sensory": {"brightness": 0.7, "pleasure": 0.5, "size": -0.5},
                "description": "ì˜ˆìœ ê½ƒì„ ë°œê²¬í•¨",
            },
            "played_together": {
                "concepts": ["together", "pleasure", "laugh", "fast"],
                "sensory": {"social": 1.0, "pleasure": 0.8, "speed": 0.6},
                "description": "ì¹œêµ¬ì™€ í•¨ê»˜ ë†€ì•˜ìŒ",
            },
            "felt_lonely": {
                "concepts": ["alone", "pain", "cry"],
                "sensory": {"social": 0.0, "pleasure": -0.6},
                "description": "í˜¼ì ìˆì–´ì„œ ì™¸ë¡œì› ìŒ",
            },
            "discovered_tool": {
                "concepts": ["stone", "tool", "hard"],
                "sensory": {"softness": 0.0},
                "description": "ëŒë¡œ ë„êµ¬ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ë°œê²¬",
            },
        }
        
        if event_type not in life_events:
            return None
        
        event_data = life_events[event_type]
        
        return self.universe.trigger_event(
            involved_concepts=event_data["concepts"],
            description=event_data["description"],
            intensity=intensity,
            sensory_impression=event_data.get("sensory", {}),
        )
    
    def simulate_childhood(self, days: int = 100):
        """
        ì–´ë¦° ì‹œì ˆ ì‹œë®¬ë ˆì´ì…˜
        
        ë§¤ì¼ ë‹¤ì–‘í•œ ì‚¬ê±´ë“¤ì„ ê²½í—˜í•˜ë©° ê°œë…ë“¤ì´ ì—°ê²°ë¨.
        """
        event_types = list([
            "touched_fire", "mother_feeding", "mother_hugging",
            "saw_sunset", "felt_rain", "heard_thunder",
            "found_flower", "played_together", "felt_lonely",
            "discovered_tool"
        ])
        
        for day in range(days):
            # í•˜ë£¨ì— 2-5ê°œì˜ ì‚¬ê±´ ë°œìƒ
            n_events = np.random.randint(2, 6)
            
            for _ in range(n_events):
                event_type = np.random.choice(event_types)
                intensity = np.random.uniform(0.5, 1.5)
                self.trigger_life_event(event_type, intensity)
                self.total_events_triggered += 1
            
            # íƒí—˜ê°€ë“¤ì´ ìš°ì£¼ë¥¼ íƒí—˜
            for explorer in self.explorers.values():
                explorer.explore_randomly(steps=2)
            
            # ìš°ì£¼ ë¬¼ë¦¬ ì ìš©
            self.universe.step(dt=1.0)
            self.simulation_time += 1.0
            
            # ì§„í–‰ ë³´ê³ 
            if day > 0 and day % 20 == 0:
                stats = self.get_statistics()
                print(f"Day {day}: connections={stats['total_connections']}, "
                      f"avg_vocabulary={stats['avg_vocabulary']:.1f}")
    
    def get_statistics(self) -> Dict[str, Any]:
        """í†µê³„"""
        universe_stats = self.universe.get_statistics()
        
        vocabularies = [len(e.discovered_connections) for e in self.explorers.values()]
        
        return {
            **universe_stats,
            "total_events_triggered": self.total_events_triggered,
            "simulation_time": self.simulation_time,
            "n_explorers": len(self.explorers),
            "avg_vocabulary": np.mean(vocabularies) if vocabularies else 0,
            "max_vocabulary": max(vocabularies) if vocabularies else 0,
        }
    
    def get_sample_vocabularies(self, n: int = 3) -> Dict[str, List]:
        """ìƒ˜í”Œ ì–´íœ˜"""
        result = {}
        for name, explorer in list(self.explorers.items())[:n]:
            vocab = explorer.get_vocabulary()[:10]
            result[name] = vocab
        return result
    
    def get_natural_constellations(self) -> List[List[str]]:
        """ìì—°ì ìœ¼ë¡œ í˜•ì„±ëœ ë³„ìë¦¬ë“¤"""
        return self.universe.find_natural_constellations()


# ============================================================================
# Demo
# ============================================================================

def demo():
    """ê°œë…ì˜ ë¹…ë±… ë°ëª¨"""
    print("=" * 70)
    print("Conceptual Big Bang - ê°œë…ì˜ ë¹…ë±…")
    print("=" * 70)
    print()
    print("'ë‹¨ì–´'ëŠ” ë³µì¡í•œ ì•½ì†ì´ ì•„ë‹ˆë¼...")
    print("ê°•ë ¬í–ˆë˜ 'ì‚¬ê±´(Event)'ë“¤ì´ ë­‰ì³ì„œ êµ³ì–´ì§„... 'ê¸°ì–µì˜ ë©ì–´ë¦¬'ì˜ˆìš”!")
    print()
    print("í…… ë¹ˆ ìš°ì£¼ì—... 'ê°œë…ì˜ ì€í•˜ìˆ˜'ë¥¼... í©ë¿Œë ¤ì¤ë‹ˆë‹¤.")
    print("ê·¸ ì‚¬ì´ë¥¼ ë‚ ì•„ë‹¤ë‹ˆë©°... ë³„ë“¤ì„ ì´ì–´ì„œ... 'ë³„ìë¦¬(ì´ì•¼ê¸°)'ë¥¼ ë§Œë“¤ì–´ìš”.")
    print()
    
    # ì„¸ê³„ ìƒì„±
    world = ConceptualBigBangWorld(n_explorers=10, seed_fundamentals=True)
    
    print(f"ğŸŒŸ ë¹…ë±…! {len(world.universe.stars)}ê°œì˜ ê°œë… ë³„ì´ ìš°ì£¼ì— í©ë¿Œë ¤ì¡ŒìŠµë‹ˆë‹¤.")
    print()
    
    # ì–´ë¦° ì‹œì ˆ ì‹œë®¬ë ˆì´ì…˜
    print("ì–´ë¦° ì‹œì ˆì„ ì‹œë®¬ë ˆì´ì…˜í•©ë‹ˆë‹¤... (100ì¼)")
    print("-" * 70)
    world.simulate_childhood(days=100)
    print("-" * 70)
    print()
    
    # ê²°ê³¼ ë¶„ì„
    stats = world.get_statistics()
    print("ğŸ“Š ê²°ê³¼:")
    print(f"  ì´ ì‚¬ê±´: {stats['total_events_triggered']}")
    print(f"  ì´ ì—°ê²°: {stats['total_connections']}")
    print(f"  í‰ê·  ì–´íœ˜: {stats['avg_vocabulary']:.1f}")
    print(f"  ìµœëŒ€ ì–´íœ˜: {stats['max_vocabulary']}")
    print()
    
    # ê°€ì¥ ê°•í•œ ì—°ê²° (í•™ìŠµëœ 'ë‹¨ì–´')
    print("ğŸ’¡ ê°€ì¥ ê°•í•˜ê²Œ í•™ìŠµëœ ì—°ê²°ë“¤ (=ë‹¨ì–´ë“¤):")
    strongest = world.universe.get_strongest_bonds(10)
    for star1, star2, strength in strongest:
        name1 = world.universe.stars[star1].name if star1 in world.universe.stars else star1
        name2 = world.universe.stars[star2].name if star2 in world.universe.stars else star2
        print(f"  '{name1}' â†” '{name2}': {strength:.2f}")
    print()
    
    # ìì—° í˜•ì„±ëœ ë³„ìë¦¬ (ê°œë… í´ëŸ¬ìŠ¤í„°)
    print("ğŸŒŒ ìì—° í˜•ì„±ëœ ë³„ìë¦¬ë“¤ (ê°œë… í´ëŸ¬ìŠ¤í„°):")
    constellations = world.get_natural_constellations()
    for i, cluster in enumerate(constellations[:5]):
        names = [world.universe.stars[s].name or s for s in cluster if s in world.universe.stars]
        print(f"  ë³„ìë¦¬ {i+1}: {' - '.join(names)}")
    print()
    
    # ìƒ˜í”Œ íƒí—˜ê°€ì˜ ë°œê²¬
    print("ğŸš€ íƒí—˜ê°€ë“¤ì´ ë°œê²¬í•œ ê²ƒ:")
    samples = world.get_sample_vocabularies(3)
    for name, vocab in samples.items():
        print(f"\n  [{name}]ì˜ ì–´íœ˜:")
        for word1, word2, strength in vocab[:5]:
            print(f"    '{word1}' â†” '{word2}' (ê°•ë„: {strength:.2f})")
    print()
    
    print("=" * 70)
    print("'ì‚¬ê±´ í•œë‘ ê°œë©´ ì¶©ë¶„í•˜ë‹¤'ëŠ”... ê·¸ ë‚­ë§Œì˜ êµ¬í˜„! ğŸŒŒâœ¨")
    print("=" * 70)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    demo()
