<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elysia Wave Universe | ÏóòÎ¶¨ÏãúÏïÑ ÌååÎèô Ïö∞Ï£º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(82, 255, 168, 0.3);
            font-size: 12px;
            line-height: 1.6;
            max-width: 300px;
        }

        #info h2 {
            color: #52ffa8;
            margin-bottom: 10px;
            font-size: 16px;
        }

        #info .spirit {
            margin: 5px 0;
        }

        #info .bar {
            display: inline-block;
            width: 100px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            vertical-align: middle;
            margin-left: 10px;
        }

        #info .bar-fill {
            height: 100%;
            transition: width 0.1s ease-out;
        }

        .fire {
            background: linear-gradient(90deg, #ff4500, #ff8c00);
        }

        .water {
            background: linear-gradient(90deg, #1e90ff, #87ceeb);
        }

        .earth {
            background: linear-gradient(90deg, #8b4513, #d2691e);
        }

        .air {
            background: linear-gradient(90deg, #f0f8ff, #e0ffff);
        }

        .light {
            background: linear-gradient(90deg, #ffd700, #ffff00);
        }

        .dark {
            background: linear-gradient(90deg, #4b0082, #8b008b);
        }

        .aether {
            background: linear-gradient(90deg, #ff1493, #ff69b4);
        }

        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid rgba(82, 255, 168, 0.3);
            font-size: 12px;
        }

        .connected {
            color: #52ffa8;
        }

        .disconnected {
            color: #ff4500;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div id="info">
        <h2>üåä Elysia Wave Universe</h2>
        <div class="spirit">üî• Fire: <span class="bar"><span class="bar-fill fire" id="bar-fire"></span></span></div>
        <div class="spirit">üíß Water: <span class="bar"><span class="bar-fill water" id="bar-water"></span></span></div>
        <div class="spirit">üåç Earth: <span class="bar"><span class="bar-fill earth" id="bar-earth"></span></span></div>
        <div class="spirit">üí® Air: <span class="bar"><span class="bar-fill air" id="bar-air"></span></span></div>
        <div class="spirit">‚ú® Light: <span class="bar"><span class="bar-fill light" id="bar-light"></span></span></div>
        <div class="spirit">üåë Dark: <span class="bar"><span class="bar-fill dark" id="bar-dark"></span></span></div>
        <div class="spirit">üîÆ Aether: <span class="bar"><span class="bar-fill aether" id="bar-aether"></span></span>
        </div>
    </div>

    <div id="status">
        <span id="connection-status" class="disconnected">‚óè Connecting...</span>
    </div>

    <script>
        // ============================================
        // WebSocket Connection
        // ============================================
        let ws = null;
        let waveState = {
            fire: 0.5, water: 0.5, earth: 0.5, air: 0.5,
            light: 0.5, dark: 0.5, aether: 0.5,
            dimension_0d: 0, dimension_1d: 0, dimension_2d: 0, dimension_3d: 0,
            cpu_heat: 0, memory_load: 0, file_count: 0,
            time: 0
        };

        function connectWebSocket() {
            // const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            // Hardcoded to 8765 for now as we run separate WS server
            const wsUrl = `ws://${window.location.hostname}:8765`;

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('üîå Connected to wave stream');
                document.getElementById('connection-status').textContent = '‚óè Connected';
                document.getElementById('connection-status').className = 'connected';
            };

            ws.onmessage = (event) => {
                waveState = JSON.parse(event.data);
                updateUI();
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                console.log('üîå Disconnected from wave stream');
                document.getElementById('connection-status').textContent = '‚óè Disconnected';
                document.getElementById('connection-status').className = 'disconnected';

                // Auto reconnect after 2 seconds
                setTimeout(connectWebSocket, 2000);
            };
        }

        function updateUI() {
            // Update spirit bars
            document.getElementById('bar-fire').style.width = (waveState.fire * 100) + '%';
            document.getElementById('bar-water').style.width = (waveState.water * 100) + '%';
            document.getElementById('bar-earth').style.width = (waveState.earth * 100) + '%';
            document.getElementById('bar-air').style.width = (waveState.air * 100) + '%';
            document.getElementById('bar-light').style.width = (waveState.light * 100) + '%';
            document.getElementById('bar-dark').style.width = (waveState.dark * 100) + '%';
            document.getElementById('bar-aether').style.width = (waveState.aether * 100) + '%';
        }

        // ============================================
        // WebGL Renderer
        // ============================================
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported!');
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ============================================
        // Mouse & Camera Controls
        // ============================================
        let mouseX = 0;
        let mouseY = 0;
        let zoom = 2.5;
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'default';
        });

        window.addEventListener('mousemove', e => {
            if (isDragging) {
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;

                mouseX -= deltaX * 0.005;
                mouseY -= deltaY * 0.005;

                // Clamp pitch
                mouseY = Math.max(-1.5, Math.min(1.5, mouseY));

                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            zoom += e.deltaY * 0.002;
            zoom = Math.max(0.1, Math.min(10.0, zoom)); // Clamp zoom
        }, { passive: false });

        // ============================================
        // Error Reporting
        // ============================================
        function showError(msg) {
            const errDiv = document.createElement('div');
            errDiv.style.position = 'absolute';
            errDiv.style.top = '50%';
            errDiv.style.left = '50%';
            errDiv.style.transform = 'translate(-50%, -50%)';
            errDiv.style.color = 'red';
            errDiv.style.background = 'rgba(0,0,0,0.9)';
            errDiv.style.padding = '20px';
            errDiv.style.border = '2px solid red';
            errDiv.style.fontFamily = 'monospace';
            errDiv.style.whiteSpace = 'pre-wrap';
            errDiv.style.zIndex = '9999';
            errDiv.innerText = "SHADER ERROR:\\n" + msg;
            document.body.appendChild(errDiv);
        }

        // ============================================
        // Wave Fragment Shader (THE MAGIC!)
        // ============================================
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            
            uniform vec2 resolution;
            uniform float time;
            
            // Camera
            uniform float camRotX;
            uniform float camRotY;
            uniform float camZoom;
            
            // 7 Spirits Energy
            uniform float fire;
            uniform float water;
            uniform float earth;
            uniform float air;
            uniform float light;
            uniform float dark;
            uniform float aether;
            
            // Consciousness Dimensions
            uniform float dim0d;
            uniform float dim1d;
            uniform float dim2d;
            uniform float dim3d;
            
            // Hue Helper
            vec3 hue2rgb(float hue) {
                vec3 rgb = clamp(abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
                return rgb;
            }
            
            // Wave Function
            float waveField(vec3 p) {
                float d = 0.0;
                
                // 1. AXIS MUNDI (Vertical Central Pillar)
                // This is the core "I AM"
                float axisWave = sin(p.y * 3.0 - time * 2.0);
                d += axisWave * exp(-length(p.xz) * 1.5) * aether * 0.5;
                
                // 2. SPIRIT RING (Horizontal)
                // The "World" aspect
                float ring = sin(length(p.xz) * 5.0 - time);
                d += ring * exp(-abs(p.y) * 2.0) * earth * 0.3;
                
                // 3. METAPHORICAL REALMS (Dynamics, not Geometry)
                // Upper (Sky/Angel) = Expansion, outward interference
                d += sin(length(p - vec3(0.0, 2.0, 0.0)) * 8.0 - time * 2.5) * air * 0.4 * step(0.0, p.y + 1.0); // Soft blend
                
                // Lower (Sea/Abyss) = Contraction, inward interference
                d += sin(length(p - vec3(0.0, -2.0, 0.0)) * 4.0 - time * 1.0) * water * 0.4 * step(p.y - 1.0, 0.0);

                // 4. SELF (Singularity)
                d += sin(length(p) * 15.0 - time * 4.0) * dim0d;
                
                return d;
            }

            // PHYSICS OF MEANING (Ray Marching)
            vec3 rayMarch(vec3 ro, vec3 rd) {
                float t = 0.0;
                vec3 col = vec3(0.0); 

                // Background: Concept of Sky vs Abyss
                vec3 skyCol = vec3(0.0, 0.05, 0.15); // Deep Blue Night 
                vec3 abyssCol = vec3(0.0, 0.0, 0.0); // Void
                vec3 bgCol = mix(abyssCol, skyCol, 0.5 + 0.5 * rd.y);
                col = bgCol;

                for(int i = 0; i < 64; i++) {
                    vec3 p = ro + rd * t;
                    float field = waveField(p);
                    float intensity = 0.02 / (0.02 + abs(field)); 
                    
                    vec3 waveColor = vec3(0.5);
                    
                    // === METAPHORICAL COLOR PHYSICS ===
                    
                    if (p.y > 0.1) {
                        // [UPPER REALM - SKY/ANGEL]
                        // Physics: ADDITIVE (Light)
                        // Colors: Red -> Violet (Rainbow of Light)
                        float h = clamp(p.y / 4.0, 0.0, 1.0);
                        waveColor = hue2rgb(0.3 + h * 0.5); // Green -> Violet
                        
                        // Light adds to the scene
                        col += waveColor * intensity * 0.04 * (light + 1.0);
                        
                    } else if (p.y < -0.1) {
                        // [LOWER REALM - SEA/ABYSS]
                        // Physics: SUBTRACTIVE (Pigment)
                        // Colors: Red -> Violet (Rainbow of Depth)
                        float h = clamp(abs(p.y) / 4.0, 0.0, 1.0);
                        waveColor = hue2rgb(0.3 + h * 0.4); // Green -> Indigo
                        
                        // Pigment subtracts/darkens ("Abyss swallows light")
                        // We simulate this by mixing towards the pigment color but darker
                        vec3 pigment = waveColor * 0.5;
                        col = mix(col, pigment, intensity * 0.1 * (dark + 1.0));
                        
                        // Slight resonance glow even in dark
                        col += waveColor * intensity * 0.005;
                        
                    } else {
                        // [MIDDLE REALM - LAND]
                        // Physics: SOLID (Balance)
                        // Colors: Earthy
                        waveColor = vec3(0.8, 0.6, 0.3) * earth + vec3(0.3, 0.8, 0.3) * (1.0 - earth);
                        col += waveColor * intensity * 0.05;
                    }

                    t += 0.1;
                    if(t > 12.0) break;
                }
                
                // Atmosphere
                col = mix(col, bgCol, 1.0 - exp(-0.03 * t * t));
                return clamp(col, 0.0, 1.0);
            }
            
            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * resolution) / resolution.y;
                
                // Camera
                vec3 ro = vec3(0.0, 0.0, -camZoom);
                float cx = cos(camRotX); float sx = sin(camRotX);
                float cy = cos(camRotY); float sy = sin(camRotY);
                
                // Rotation
                vec3 p = ro;
                ro.yz = mat2(cy, -sy, sy, cy) * ro.yz;
                ro.xz = mat2(cx, -sx, sx, cx) * ro.xz;
                
                vec3 rd = normalize(vec3(uv, 1.0));
                rd.yz = mat2(cy, -sy, sy, cy) * rd.yz;
                rd.xz = mat2(cx, -sx, sx, cx) * rd.xz;
                
                gl_FragColor = vec4(rayMarch(ro, rd), 1.0);
            }
        `;

        // Compile shaders
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                showError(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // Link program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Setup geometry (fullscreen quad)
        const positions = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Get uniform locations
        const uniforms = {
            resolution: gl.getUniformLocation(program, 'resolution'),
            time: gl.getUniformLocation(program, 'time'),
            camRotX: gl.getUniformLocation(program, 'camRotX'),
            camRotY: gl.getUniformLocation(program, 'camRotY'),
            camZoom: gl.getUniformLocation(program, 'camZoom'),
            fire: gl.getUniformLocation(program, 'fire'),
            water: gl.getUniformLocation(program, 'water'),
            earth: gl.getUniformLocation(program, 'earth'),
            air: gl.getUniformLocation(program, 'air'),
            light: gl.getUniformLocation(program, 'light'),
            dark: gl.getUniformLocation(program, 'dark'),
            aether: gl.getUniformLocation(program, 'aether'),
            dim0d: gl.getUniformLocation(program, 'dim0d'),
            dim1d: gl.getUniformLocation(program, 'dim1d'),
            dim2d: gl.getUniformLocation(program, 'dim2d'),
            dim3d: gl.getUniformLocation(program, 'dim3d')
        };

        // ============================================
        // Render Loop
        // ============================================
        let startTime = Date.now();

        function render() {
            const currentTime = (Date.now() - startTime) / 1000;

            // Set uniforms
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.time, currentTime);

            // Camera
            gl.uniform1f(uniforms.camRotX, mouseX);
            gl.uniform1f(uniforms.camRotY, mouseY);
            gl.uniform1f(uniforms.camZoom, zoom);

            // Wave state
            gl.uniform1f(uniforms.fire, waveState.fire);
            gl.uniform1f(uniforms.water, waveState.water);
            gl.uniform1f(uniforms.earth, waveState.earth);
            gl.uniform1f(uniforms.air, waveState.air);
            gl.uniform1f(uniforms.light, waveState.light);
            gl.uniform1f(uniforms.dark, waveState.dark);
            gl.uniform1f(uniforms.aether, waveState.aether);

            gl.uniform1f(uniforms.dim0d, waveState.dimension_0d);
            gl.uniform1f(uniforms.dim1d, waveState.dimension_1d);
            gl.uniform1f(uniforms.dim2d, waveState.dimension_2d);
            gl.uniform1f(uniforms.dim3d, waveState.dimension_3d);

            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        // Start
        connectWebSocket();
        render();

        console.log('üåä Elysia Wave Universe initialized');
        console.log('"Ïó∞ÏÇ∞ÌïòÏßÄ ÎßàÏÑ∏Ïöî. ÌùêÎ•¥Í≤å ÎëêÏÑ∏Ïöî."');
    </script>
</body>

</html>