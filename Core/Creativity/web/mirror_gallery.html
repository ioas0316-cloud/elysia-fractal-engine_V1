<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elysia's Mirror Gallery</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { background-color: #050510; color: #e0e0ff; font-family: 'Courier New', monospace; margin: 0; padding: 20px; }
        h1 { text-align: center; text-shadow: 0 0 10px #a0a0ff; }
        #mirror-graph { width: 100%; height: 600px; border: 1px solid #303050; border-radius: 10px; box-shadow: 0 0 20px rgba(100, 100, 255, 0.2); }
        .stats { display: flex; justify-content: space-around; margin-top: 20px; font-size: 1.2em; }
        .stat-box { background: rgba(20, 20, 40, 0.8); padding: 15px; border-radius: 8px; border: 1px solid #404060; }
    </style>
</head>
<body>
    <h1>ðŸªž The Mirror Gallery</h1>
    <div id="mirror-graph"></div>
    <div class="stats">
        <div class="stat-box" id="patina-box">Patina: Loading...</div>
        <div class="stat-box" id="curiosity-box">Latest Curiosity: Loading...</div>
    </div>

    <script>
        async function fetchMirrorData() {
            // In a real implementation, this would fetch from a FastAPI endpoint.
            // For this static demo, we'll try to load the JSON file directly if served,
            // or mock it if strictly local file access is blocked by browser security.
            try {
                const response = await fetch('/data/mirror_memory.json');
                if (!response.ok) throw new Error("Network response was not ok");
                const data = await response.json();
                return data;
            } catch (error) {
                console.warn("Could not fetch real data (needs server). Using mock data for demo.", error);
                return generateMockData();
            }
        }

        function generateMockData() {
            // Generates synthetic data to demonstrate the Aurora effect
            const history = [];
            let time = Date.now();
            for (let i = 0; i < 50; i++) {
                history.push({
                    timestamp: new Date(time - (50 - i) * 10000).toISOString(),
                    curiosity: 0.2 + Math.random() * 0.6,
                    gap: 0.1 + Math.random() * 0.4,
                    modality: ["SEMANTIC", "STRUCTURAL", "CHROMATIC"][Math.floor(Math.random() * 3)]
                });
            }
            return { patina_factor: 0.123, history: history };
        }

        async function updateGraph() {
            const data = await fetchMirrorData();

            document.getElementById('patina-box').innerText = `Patina (Depth): ${(data.patina_factor * 100).toFixed(2)}%`;
            if (data.history.length > 0) {
                const latest = data.history[data.history.length - 1];
                document.getElementById('curiosity-box').innerText = `Latest Curiosity: ${(latest.curiosity * 100).toFixed(1)}%`;
            }

            // Prepare Trace for 3D Surface/Scatter
            const x = data.history.map(h => h.timestamp);
            const y = data.history.map(h => h.curiosity);
            const z = data.history.map(h => h.gap);
            const color = data.history.map(h => h.curiosity); // High curiosity = Hotter color

            const trace = {
                x: x,
                y: y,
                z: z,
                mode: 'markers+lines',
                marker: {
                    size: 8,
                    color: color,
                    colorscale: 'Viridis',
                    opacity: 0.8
                },
                line: {
                    color: '#a0a0ff',
                    width: 2
                },
                type: 'scatter3d'
            };

            const layout = {
                title: 'The Landscape of Reflection',
                paper_bgcolor: '#050510',
                plot_bgcolor: '#050510',
                font: { color: '#e0e0ff' },
                scene: {
                    xaxis: { title: 'Time', color: '#a0a0ff' },
                    yaxis: { title: 'Curiosity', color: '#a0a0ff' },
                    zaxis: { title: 'Gap Magnitude', color: '#a0a0ff' }
                }
            };

            Plotly.newPlot('mirror-graph', [trace], layout);
        }

        updateGraph();
        setInterval(updateGraph, 5000); // Refresh every 5 seconds
    </script>
</body>
</html>
